This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/
  gallery-client.tsx
  globals.css
  layout.tsx
  page.tsx
components/
  mobile/
    BottomSheet.tsx
    FilterPanel.tsx
    LoadingState.tsx
    MinimalBottomSheet.tsx
    Toast.tsx
    TopUtilityBar.tsx
    UltraMinimalSearch.tsx
  BottomControls.tsx
  BottomSheet.tsx
  CategoryBar.tsx
  DynamicSpherePositions.ts
  FilterSidebar.tsx
  FloatingMetadata.tsx
  ImageFullscreenModal.tsx
  ImageModal.tsx
  InfiniteMenu.tsx
  MetadataPanel.tsx
  MobileFilterModal.tsx
  MobileHeader.tsx
  MobileSearchModal.tsx
  TopNav.tsx
hooks/
  useAutoHide.ts
  useMediaQuery.ts
lib/
  format.ts
  staticTypes.ts
  supabase.ts
migrations/
  001_improved_categorization.sql
  003_enhanced_search.sql
  004_fix_filtered_view.sql
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
types/
  global.d.ts
.gitignore
.repomixignore
CLAUDE.md
eslint.config.mjs
next.config.ts
package.json
postcss.config.mjs
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".repomixignore">
# Repomix ignore file - only include core app files

# Exclude all scripts and build tools
scripts/
data/
docs/

# Exclude build outputs and dependencies
.next/
node_modules/
dist/
build/
out/

# Exclude environment and config files
.env*
.git/
.github/
.cursor/
.claude/
.DS_Store

# Exclude test and development files
.playwright-mcp/
*.test.*
*.spec.*
__tests__/
coverage/

# Exclude public assets (generated atlas files and images)
public/atlas-*
public/*.webp
public/*.json

# Exclude documentation (keep CLAUDE.md for context)
*.md
!CLAUDE.md

# Exclude lock files and logs
package-lock.json
yarn.lock
pnpm-lock.yaml
*.log

# Exclude IDE and editor files
.vscode/
.idea/
*.swp
*.swo
*~

# Include only essential config files
!package.json
!tsconfig.json
!next.config.js
!tailwind.config.ts
!postcss.config.js
!eslint.config.mjs
</file>

<file path="app/gallery-client.tsx">
'use client';

import { useEffect, useState, useCallback } from 'react';
import dynamic from 'next/dynamic';
import type { StaticNFTData } from '@/lib/staticTypes';
import { mapNFTToMenuItem } from '@/lib/supabase';
import TopNav from '@/components/TopNav';
import FilterSidebar from '@/components/FilterSidebar';
import MetadataPanel from '@/components/MetadataPanel';
import BottomControls from '@/components/BottomControls';
import ImageModal from '@/components/ImageModal';
import MobileHeader from '@/components/MobileHeader';
import BottomSheet from '@/components/BottomSheet';
import MobileFilterModal from '@/components/MobileFilterModal';
import MobileSearchModal from '@/components/MobileSearchModal';

const InfiniteMenu = dynamic(
  () => import('@/components/InfiniteMenu'),
  { 
    ssr: false,
    loading: () => (
      <div className="w-full h-screen flex items-center justify-center bg-black text-white">
        <p className="font-mono text-xs uppercase tracking-[0.08em]">Loading...</p>
      </div>
    )
  }
);

interface MenuItem {
  id?: number;
  image: string;
  link: string;
  title: string;
  description: string;
  mintUrl?: string | null;
  createdAt?: string | null;
  categories?: string[];
  network?: string | null;
  collectionAddress?: string | null;
}

interface GalleryClientProps {
  initialData: StaticNFTData;
}

export default function GalleryClient({ initialData }: GalleryClientProps) {
  const [allItems] = useState<MenuItem[]>(() => 
    initialData.items.map(mapNFTToMenuItem)
  );
  const [filteredItems, setFilteredItems] = useState<MenuItem[]>(allItems);
  const [categories] = useState<string[]>(initialData.categories);
  const [activeCategories, setActiveCategories] = useState<string[]>([]);
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [submittedQuery, setSubmittedQuery] = useState<string>('');
  const [focusedItem, setFocusedItem] = useState<MenuItem | null>(null);
  const [isImageModalOpen, setIsImageModalOpen] = useState(false);
  const [isMobileFilterOpen, setIsMobileFilterOpen] = useState(false);
  const [isMobileSearchOpen, setIsMobileSearchOpen] = useState(false);

  // Filter items based on categories and search
  useEffect(() => {
    let filtered = allItems;
    
    // Apply category filter
    if (activeCategories.length > 0) {
      filtered = filtered.filter(item => 
        item.categories?.some(cat => activeCategories.includes(cat))
      );
    }
    
    // Apply search filter
    if (searchQuery.trim()) {
      const query = searchQuery.toLowerCase();
      filtered = filtered.filter(item => 
        item.title?.toLowerCase().includes(query) ||
        item.description?.toLowerCase().includes(query)
      );
    }
    
    setFilteredItems(filtered);
  }, [allItems, activeCategories, searchQuery]);

  const handleCategoryToggle = useCallback((category: string) => {
    setActiveCategories((prev) => {
      const exists = prev.includes(category);
      if (exists) return prev.filter((c) => c !== category);
      return [...prev, category];
    });
  }, []);

  const handleSearchChange = useCallback((value: string) => {
    setSearchQuery(value);
    if (!value) {
      setSubmittedQuery('');
    }
  }, []);

  const handleSearchSubmit = useCallback(() => {
    setSubmittedQuery(searchQuery);
  }, [searchQuery]);

  const handleExpandClick = useCallback(() => {
    setIsImageModalOpen(true);
  }, []);

  const handleItemFocus = useCallback((item: MenuItem | null) => {
    setFocusedItem(item);
  }, []);

  // Map focused item for components
  const selectedItem = focusedItem ? {
    id: String(focusedItem.id ?? ''),
    title: focusedItem.title,
    description: focusedItem.description,
    category: focusedItem.categories,
    image_url: focusedItem.image,
    mint_url: focusedItem.mintUrl || undefined,
    collection_address: focusedItem.collectionAddress || undefined,
    token_id: String(focusedItem.id ?? ''),
    network: focusedItem.network || undefined,
    created_at: focusedItem.createdAt ?? undefined,
  } : null;

  return (
    <main className="relative w-screen h-screen overflow-hidden bg-black">
      {/* Desktop Layout */}
      <div className="hidden md:block">
        {/* Top Navigation */}
        <TopNav 
          searchQuery={searchQuery}
          onSearchChange={handleSearchChange}
        />

        {/* Main Content Area */}
        <div className="fixed top-16 left-0 right-0 bottom-0">
          {/* Filter Sidebar */}
          <FilterSidebar
            categories={categories}
            selectedCategories={activeCategories}
            onCategoryToggle={handleCategoryToggle}
          />

          {/* Center - 3D Menu */}
          <div className="fixed top-16 left-40 right-80 bottom-16">
            {filteredItems.length > 0 && (
              <InfiniteMenu 
                items={filteredItems} 
                initialFocusId={activeCategories.length === 0 && !searchQuery ? 755 : undefined}
                onItemFocus={handleItemFocus}
              />
            )}

            {filteredItems.length === 0 && (
              <div className="h-full flex items-center justify-center">
                <div className="font-mono text-white text-center">
                  <p className="text-sm uppercase tracking-[0.08em] mb-2">No items found</p>
                  <p className="text-xs text-white/60">
                    {searchQuery ? 'Try a different search term' : 'No items in this category'}
                  </p>
                </div>
              </div>
            )}
          </div>

          {/* Metadata Panel */}
          <MetadataPanel selectedItem={selectedItem} />

          {/* Bottom Controls */}
          <BottomControls 
            itemCount={filteredItems.length}
            onExpandClick={handleExpandClick}
          />
        </div>
      </div>

      {/* Mobile Layout */}
      <div className="md:hidden">
        {/* Mobile Header */}
        <MobileHeader
          onFilterClick={() => setIsMobileFilterOpen(true)}
          onSearchClick={() => setIsMobileSearchOpen(true)}
          activeFilterCount={activeCategories.length}
          hasSearchQuery={!!searchQuery}
        />

        {/* Mobile Main Content */}
        <div className="fixed top-16 left-0 right-0 bottom-0">
          {filteredItems.length > 0 && (
            <InfiniteMenu 
              items={filteredItems} 
              initialFocusId={activeCategories.length === 0 && !searchQuery ? 755 : undefined}
              onItemFocus={handleItemFocus}
            />
          )}

          {filteredItems.length === 0 && (
            <div className="h-full flex items-center justify-center">
              <div className="font-mono text-white text-center px-4">
                <p className="text-sm uppercase tracking-[0.08em] mb-2">No items found</p>
                <p className="text-xs text-white/60">
                  {searchQuery ? 'Try a different search term' : 'No items in this category'}
                </p>
              </div>
            </div>
          )}

          {/* Mobile Expand Button - Overlay on sphere */}
          {focusedItem && (
            <button
              onClick={handleExpandClick}
              className="fixed bottom-24 right-4 w-12 h-12 bg-white/10 backdrop-blur rounded-full flex items-center justify-center z-40"
              aria-label="Expand image"
            >
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M15 3h6v6M9 21H3v-6M21 3l-7 7M3 21l7-7" className="text-white" />
              </svg>
            </button>
          )}
        </div>

        {/* Mobile Bottom Sheet */}
        <BottomSheet 
          selectedItem={selectedItem}
          onExpandImage={handleExpandClick}
        />

        {/* Mobile Filter Modal */}
        <MobileFilterModal
          isOpen={isMobileFilterOpen}
          categories={categories}
          selectedCategories={activeCategories}
          onCategoryToggle={handleCategoryToggle}
          onClose={() => setIsMobileFilterOpen(false)}
        />

        {/* Mobile Search Modal */}
        <MobileSearchModal
          isOpen={isMobileSearchOpen}
          searchQuery={searchQuery}
          submittedQuery={submittedQuery}
          onSearchChange={handleSearchChange}
          onSearchSubmit={handleSearchSubmit}
          onClose={() => setIsMobileSearchOpen(false)}
        />
      </div>

      {/* Image Modal - Shared between desktop and mobile */}
      <ImageModal
        isOpen={isImageModalOpen}
        imageUrl={focusedItem?.image}
        title={focusedItem?.title}
        onClose={() => setIsImageModalOpen(false)}
      />
    </main>
  );
}
</file>

<file path="components/mobile/BottomSheet.tsx">
'use client';

import { useState, useRef, useEffect } from 'react';
import { Sheet } from 'react-modal-sheet';
import { CalendarBlank, Hash, Globe, Export, Heart, ShareNetwork, Copy } from 'phosphor-react';

interface MenuItem {
  id?: number;
  image: string;
  link: string;
  title: string;
  description: string;
  mintUrl?: string | null;
  createdAt?: string | null;
  categories?: string[]
;
  network?: string | null;
  collectionAddress?: string | null;
}

interface BottomSheetProps {
  item: MenuItem | null;
  isOpen: boolean;
  onClose?: () => void;
  isSphereInteracting?: boolean;
  onExpandedChange?: (expanded: boolean) => void;
}

export default function BottomSheet({ item, isOpen, onClose, isSphereInteracting = false, onExpandedChange }: BottomSheetProps) {
  const [snapPoint, setSnapPoint] = useState(0);
  const ref = useRef<HTMLDivElement>(null);
  const [isFavorited, setIsFavorited] = useState(false);
  const [showFullDescription, setShowFullDescription] = useState(false);
  const contentRef = useRef<HTMLDivElement>(null);
  const [contentHeight, setContentHeight] = useState(0);

  // Calculate snap points - only 2 states now
  const getSnapPoints = () => {
    const height = window.innerHeight;
    const minHeight = 72; // Ultra-minimal collapsed state
    // Dynamic height based on content, max 75% of screen for more content space
    const maxHeight = Math.min(contentHeight + 120, height * 0.75);
    
    return [minHeight, maxHeight];
  };

  const [snapPoints, setSnapPoints] = useState(getSnapPoints);

  // Update snap points when content changes
  useEffect(() => {
    if (contentRef.current) {
      const height = contentRef.current.scrollHeight;
      setContentHeight(height);
    }
  }, [item, showFullDescription]);

  useEffect(() => {
    setSnapPoints(getSnapPoints());
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [contentHeight]);

  useEffect(() => {
    const handleResize = () => {
      setSnapPoints(getSnapPoints());
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [contentHeight]);

  // Reset to collapsed when item changes - immediate and reliable
  useEffect(() => {
    if (item) {
      // Force immediate collapse on new item
      setSnapPoint(0);
      setShowFullDescription(false);
    }
  }, [item?.id, item?.title, item]); // Multiple dependencies to ensure it triggers

  // Auto-collapse when sphere is being interacted with
  useEffect(() => {
    if (isSphereInteracting && snapPoint === 1) {
      setSnapPoint(0);
    }
  }, [isSphereInteracting, snapPoint]);

  // Report expansion state changes
  useEffect(() => {
    onExpandedChange?.(snapPoint === 1);
  }, [snapPoint, onExpandedChange]);

  const formatDate = (dateString: string | null | undefined) => {
    if (!dateString) return 'Unknown date';
    const date = new Date(dateString);
    return date.toLocaleDateString('en-US', { 
      year: 'numeric', 
      month: 'short', 
      day: 'numeric' 
    });
  };

  const handleShare = async () => {
    if (!item) return;
    
    if (navigator.share) {
      try {
        await navigator.share({
          title: item.title,
          text: item.description,
          url: item.mintUrl || window.location.href
        });
      } catch {
        console.log('Share cancelled or failed');
      }
    }
  };

  const handleExpand = () => {
    setSnapPoint(1);
  };

  if (!item) return null;

  const isCollapsed = snapPoint === 0;
  const isExpanded = snapPoint === 1;
  
  // Check if description is long
  const isLongDescription = item.description.length > 200;

  return (
    <Sheet
      ref={ref}
      isOpen={isOpen}
      onClose={() => {
        onClose?.();
      }}
      snapPoints={snapPoints}
      initialSnap={0}
      onSnap={setSnapPoint}
      className="mobile-bottom-sheet"
    >
      <Sheet.Container>
        <Sheet.Header />
        <Sheet.Content disableDrag={false} style={{ overflow: isCollapsed ? 'hidden' : 'auto' }}>
          <div className="bg-black/95 backdrop-blur-sm text-white font-mono border-t border-white/5" role="region" aria-label="NFT details" aria-live="polite">
            {/* Clickable Header Area - Entire collapsed section is clickable */}
            <div 
              onClick={isCollapsed ? handleExpand : undefined}
              className={`${isCollapsed ? 'cursor-pointer active:bg-white/5' : ''} transition-colors`}
            >
              {/* Drag Handle - Enhanced Visual Affordance */}
              <div className="flex justify-center pt-3 pb-3">
                <div className="w-10 h-1 bg-white/50 rounded-full shadow-sm" />
              </div>

              {/* Title Bar - Enhanced content in collapsed state */}
              <div className="px-5 pb-3">
                <div className="flex items-center justify-between">
                  <div className="flex-1 min-w-0">
                    <h3 className="text-sm uppercase tracking-wider text-white truncate font-medium" aria-level={2}>
                      {item.title}
                    </h3>
                    {/* Show category in collapsed state for better context */}
                    {item.categories && item.categories.length > 0 && (
                      <span className="text-xs uppercase text-white/70 mt-1 block">
                        {item.categories[0]}
                      </span>
                    )}
                  </div>
                  {isCollapsed && (
                    <div className="w-2 h-2 bg-white/30 rounded-full opacity-50" />
                  )}
                </div>
              </div>
            </div>

            {/* Expanded Content - Only visible when expanded */}
            {isExpanded && (
              <div ref={contentRef} className="overflow-hidden">
                <div className="px-5 pb-6 space-y-4 border-t border-white/10 pt-5">
                    {/* Date */}
                    {item.createdAt && (
                      <div className="flex items-center gap-2 text-xs text-white/60">
                        <CalendarBlank className="w-4 h-4" weight="regular" />
                        <time className="uppercase font-medium">{formatDate(item.createdAt)}</time>
                      </div>
                    )}

                    {/* Categories */}
                    {item.categories && item.categories.length > 0 && (
                      <div className="flex flex-wrap gap-2">
                        {item.categories.map((cat, idx) => (
                          <span
                            key={idx}
                            className="px-3 py-1 bg-white/10 rounded-full text-xs uppercase text-white/80 border border-white/10"
                          >
                            {cat}
                          </span>
                        ))}
                      </div>
                    )}

                    {/* Description with Show More/Less for long text */}
                    <div className="space-y-2">
                      <p className={`text-sm text-white/80 leading-relaxed ${
                        !showFullDescription && isLongDescription ? 'line-clamp-3' : ''
                      }`} aria-label="NFT description">
                        {item.description}
                      </p>
                      {isLongDescription && (
                        <button
                          onClick={() => setShowFullDescription(!showFullDescription)}
                          className="text-xs uppercase text-white/60 hover:text-white/80 transition-colors"
                        >
                          {showFullDescription ? 'Show Less' : 'Show More'}
                        </button>
                      )}
                    </div>

                    {/* Network Info */}
                    {(item.network || item.collectionAddress) && (
                      <div className="space-y-2 pt-3 border-t border-white/10">
                        {item.network && (
                          <div className="flex items-center gap-2 text-xs text-white/70">
                            <Globe className="w-3 h-3" weight="regular" />
                            <span className="uppercase">{item.network}</span>
                          </div>
                        )}
                        {item.collectionAddress && (
                          <div className="flex items-center justify-between text-xs text-white/70">
                            <div className="flex items-center gap-2">
                              <Hash className="w-3 h-3" weight="regular" />
                              <span className="font-mono">
                                {item.collectionAddress.slice(0, 6)}...{item.collectionAddress.slice(-4)}
                              </span>
                            </div>
                            <button 
                              onClick={() => navigator.clipboard.writeText(item.collectionAddress!)}
                              className="p-1.5 hover:bg-white/10 rounded-lg transition-colors"
                              title="Copy address"
                            >
                              <Copy className="w-3 h-3" weight="regular" />
                            </button>
                          </div>
                        )}
                      </div>
                    )}

                    {/* Action Buttons */}
                    <div className="space-y-3 pt-3">
                      {/* Primary CTA */}
                      {item.mintUrl && (
                        <a
                          href={item.mintUrl}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="flex items-center justify-center gap-2 w-full py-3 bg-white text-black rounded-xl text-sm uppercase tracking-wider font-medium hover:bg-white/90 active:scale-[0.98] transition-all shadow-lg"
                          aria-label={`View ${item.title} on mint platform`}
                        >
                          VIEW ON MINT
                          <Export className="w-4 h-4" weight="regular" />
                        </a>
                      )}
                      
                      {/* Secondary Actions */}
                      <div className="grid grid-cols-2 gap-3">
                        <button
                          onClick={() => setIsFavorited(!isFavorited)}
                          className="flex items-center justify-center gap-2 py-2.5 bg-white/10 rounded-xl text-xs uppercase tracking-wider hover:bg-white/15 active:scale-[0.98] transition-all border border-white/10"
                          aria-label={isFavorited ? `Remove ${item.title} from favorites` : `Add ${item.title} to favorites`}
                        >
                          <Heart 
                            className={`w-4 h-4 ${isFavorited ? 'text-red-500' : 'text-white'}`} 
                            weight={isFavorited ? 'fill' : 'regular'} 
                          />
                          {isFavorited ? 'SAVED' : 'SAVE'}
                        </button>
                        <button
                          onClick={handleShare}
                          className="flex items-center justify-center gap-2 py-2.5 bg-white/10 rounded-xl text-xs uppercase tracking-wider hover:bg-white/15 active:scale-[0.98] transition-all border border-white/10"
                          aria-label={`Share ${item.title} NFT`}
                        >
                          <ShareNetwork className="w-4 h-4" weight="regular" />
                          SHARE
                        </button>
                      </div>
                    </div>
                </div>
              </div>
            )}
          </div>
        </Sheet.Content>
      </Sheet.Container>
      <Sheet.Backdrop />
    </Sheet>
  );
}
</file>

<file path="components/mobile/FilterPanel.tsx">
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'phosphor-react';

interface FilterPanelProps {
  isOpen: boolean;
  onClose: () => void;
  categories: string[];
  activeCategories: string[];
  onCategoryChange: (category: string | null) => void;
}

export default function FilterPanel({
  isOpen,
  onClose,
  categories,
  activeCategories,
  onCategoryChange
}: FilterPanelProps) {
  const handleCategoryClick = (category: string | null) => {
    onCategoryChange(category);
    // Auto-close after selection
    setTimeout(onClose, 150);
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <>
          {/* Backdrop */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            onClick={onClose}
            className="fixed inset-0 bg-black/50 z-30"
          />
          
          {/* Filter Panel */}
          <motion.div
            initial={{ y: '-100%' }}
            animate={{ y: 0 }}
            exit={{ y: '-100%' }}
            transition={{ type: 'spring', damping: 30, stiffness: 300 }}
            className="fixed top-0 left-0 right-0 bg-black/95 backdrop-blur-xl z-40 border-b border-white/10"
            style={{ paddingTop: '48px' }} // Account for top bar
          >
            <div className="p-4 max-h-[60vh] overflow-y-auto">
              {/* Header */}
              <div className="flex items-center justify-between mb-6">
                <h3 className="font-mono text-xs uppercase tracking-[0.2em] text-white/40">
                  FILTER BY CATEGORY
                </h3>
                <button
                  onClick={onClose}
                  className="p-2 -mr-2 rounded-lg active:bg-white/10"
                  aria-label="Close filter"
                >
                  <X className="w-5 h-5 text-white/60" />
                </button>
              </div>
              
              {/* Categories */}
              <div className="space-y-1">
                {/* All Option */}
                <button
                  onClick={() => handleCategoryClick(null)}
                  className={`flex items-center w-full font-mono text-left py-3 transition-all duration-200 text-sm relative ${
                    activeCategories.length === 0
                      ? 'text-white'
                      : 'text-white/40'
                  }`}
                >
                  <span 
                    className={`inline-block w-4 h-[1px] mr-4 transition-all duration-200 ${
                      activeCategories.length === 0 ? 'bg-white' : 'bg-transparent'
                    }`} 
                  />
                  <span className="uppercase tracking-[0.08em]">
                    ALL
                  </span>
                </button>
                
                {/* Category Options */}
                {categories.map((category) => {
                  const isActive = activeCategories.includes(category);
                  return (
                    <button
                      key={category}
                      onClick={() => handleCategoryClick(category)}
                      className={`flex items-center w-full font-mono text-left py-3 transition-all duration-200 text-sm relative ${
                        isActive
                          ? 'text-white'
                          : 'text-white/40'
                      }`}
                    >
                      <span 
                        className={`inline-block w-4 h-[1px] mr-4 transition-all duration-200 ${
                          isActive ? 'bg-white' : 'bg-transparent'
                        }`} 
                      />
                      <span className="uppercase tracking-[0.08em]">
                        {category}
                      </span>
                    </button>
                  );
                })}
              </div>
            </div>
          </motion.div>
        </>
      )}
    </AnimatePresence>
  );
}
</file>

<file path="components/mobile/LoadingState.tsx">
'use client';

import { motion } from 'framer-motion';
import { Cube, Sparkle } from 'phosphor-react';

interface LoadingStateProps {
  message?: string;
  variant?: 'default' | 'minimal' | 'sphere';
}

export default function LoadingState({ 
  message = 'LOADING...', 
  variant = 'default' 
}: LoadingStateProps) {
  if (variant === 'minimal') {
    return (
      <div className="flex items-center justify-center p-8">
        <div className="flex items-center gap-3">
          <motion.div
            animate={{ rotate: 360 }}
            transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
          >
            <Cube className="w-5 h-5 text-white/60" weight="regular" />
          </motion.div>
          <span className="font-mono text-sm uppercase tracking-wider text-white/60">
            {message}
          </span>
        </div>
      </div>
    );
  }

  if (variant === 'sphere') {
    return (
      <div className="absolute inset-0 flex items-center justify-center z-10">
        <div className="glass-subtle rounded-3xl p-8 flex flex-col items-center gap-4">
          <motion.div
            animate={{ 
              rotateX: 360,
              rotateY: 360
            }}
            transition={{ 
              duration: 3,
              repeat: Infinity,
              ease: "linear"
            }}
            className="relative"
          >
            <div className="w-12 h-12 border-2 border-white/20 rounded-full" />
            <motion.div
              animate={{ scale: [1, 1.2, 1] }}
              transition={{
                duration: 2,
                repeat: Infinity,
                ease: "easeInOut"
              }}
              className="absolute inset-2 border border-white/40 rounded-full"
            />
          </motion.div>
          
          <div className="text-center space-y-2">
            <div className="font-mono text-lg uppercase tracking-wider text-white">
              INITIALIZING 3D
            </div>
            <div className="font-mono text-xs uppercase text-white/60">
              PREPARING SPHERE VISUALIZATION
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="absolute inset-0 flex items-center justify-center z-10">
      <div className="glass rounded-2xl p-6 flex flex-col items-center gap-4 max-w-xs">
        <div className="relative">
          {/* Outer ring */}
          <motion.div
            animate={{ rotate: 360 }}
            transition={{ duration: 3, repeat: Infinity, ease: "linear" }}
            className="w-16 h-16 border-2 border-white/10 rounded-full"
          />
          
          {/* Inner rotating elements */}
          <motion.div
            animate={{ rotate: -360 }}
            transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
            className="absolute inset-2 flex items-center justify-center"
          >
            <Sparkle className="w-6 h-6 text-white/60" weight="fill" />
          </motion.div>
          
          {/* Pulsing center */}
          <motion.div
            animate={{ scale: [1, 1.2, 1], opacity: [0.5, 1, 0.5] }}
            transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
            className="absolute inset-4 bg-white/20 rounded-full"
          />
        </div>
        
        <div className="text-center space-y-1">
          <motion.div 
            className="font-mono text-sm uppercase tracking-wider text-white"
            animate={{ opacity: [1, 0.6, 1] }}
            transition={{ duration: 1.5, repeat: Infinity, ease: "easeInOut" }}
          >
            {message}
          </motion.div>
          <div className="font-mono text-xs uppercase text-white/40">
            FETCHING NFT DATA
          </div>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="components/mobile/Toast.tsx">
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { Check, Warning, X, Info } from 'phosphor-react';
import { useEffect } from 'react';

interface ToastProps {
  isVisible: boolean;
  message: string;
  type?: 'success' | 'error' | 'warning' | 'info';
  duration?: number;
  onClose: () => void;
  position?: 'top' | 'bottom';
}

export default function Toast({ 
  isVisible, 
  message, 
  type = 'info', 
  duration = 3000, 
  onClose,
  position = 'top'
}: ToastProps) {
  useEffect(() => {
    if (isVisible && duration > 0) {
      const timer = setTimeout(onClose, duration);
      return () => clearTimeout(timer);
    }
  }, [isVisible, duration, onClose]);

  const getIcon = () => {
    switch (type) {
      case 'success':
        return <Check className="w-5 h-5 text-green-400" weight="bold" />;
      case 'error':
        return <X className="w-5 h-5 text-red-400" weight="bold" />;
      case 'warning':
        return <Warning className="w-5 h-5 text-yellow-400" weight="bold" />;
      default:
        return <Info className="w-5 h-5 text-blue-400" weight="bold" />;
    }
  };

  const getColors = () => {
    switch (type) {
      case 'success':
        return 'border-green-400/30 bg-green-400/10';
      case 'error':
        return 'border-red-400/30 bg-red-400/10';
      case 'warning':
        return 'border-yellow-400/30 bg-yellow-400/10';
      default:
        return 'border-blue-400/30 bg-blue-400/10';
    }
  };

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          initial={{ 
            opacity: 0, 
            y: position === 'top' ? -100 : 100,
            scale: 0.8
          }}
          animate={{ 
            opacity: 1, 
            y: 0,
            scale: 1
          }}
          exit={{ 
            opacity: 0, 
            y: position === 'top' ? -100 : 100,
            scale: 0.8
          }}
          transition={{
            type: "spring",
            damping: 25,
            stiffness: 300
          }}
          className={`fixed ${
            position === 'top' ? 'top-6' : 'bottom-6'
          } left-4 right-4 z-50 max-w-sm mx-auto`}
        >
          <div className={`
            glass-subtle rounded-2xl p-4 border ${getColors()}
            shadow-2xl backdrop-blur-xl
          `}>
            <div className="flex items-start gap-3">
              {/* Icon */}
              <div className="flex-shrink-0 mt-0.5">
                {getIcon()}
              </div>
              
              {/* Message */}
              <div className="flex-1 min-w-0">
                <p className="font-mono text-sm text-white leading-relaxed">
                  {message}
                </p>
              </div>
              
              {/* Close Button */}
              <button
                onClick={onClose}
                className="flex-shrink-0 p-1 hover:bg-white/10 rounded-full transition-colors duration-150"
              >
                <X className="w-4 h-4 text-white/60" weight="bold" />
              </button>
            </div>
            
            {/* Progress Bar */}
            {duration > 0 && (
              <motion.div
                className="absolute bottom-0 left-0 h-0.5 bg-white/30 rounded-b-2xl"
                initial={{ width: "100%" }}
                animate={{ width: "0%" }}
                transition={{ duration: duration / 1000, ease: "linear" }}
              />
            )}
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
</file>

<file path="components/mobile/TopUtilityBar.tsx">
'use client';

import { useState, useEffect } from 'react';
import { MagnifyingGlass, Funnel, X } from 'phosphor-react';
import { motion, AnimatePresence } from 'framer-motion';

interface TopUtilityBarProps {
  onSearchChange: (query: string) => void;
  onFilterClick: () => void;
  searchQuery: string;
  autoHide?: boolean;
  forceHide?: boolean;
}

export default function TopUtilityBar({
  onSearchChange,
  onFilterClick,
  searchQuery,
  autoHide = true,
  forceHide = false
}: TopUtilityBarProps) {
  const [isSearchExpanded, setIsSearchExpanded] = useState(false);
  const [isVisible, setIsVisible] = useState(true);
  const [lastTouchY, setLastTouchY] = useState(0);

  useEffect(() => {
    if (forceHide) {
      setIsVisible(false);
      return;
    }
    
    // Always start visible when not force hidden
    setIsVisible(true);
    
    if (!autoHide) {
      return;
    }

    let timeoutId: NodeJS.Timeout;
    let isInteracting = false;

    const showBar = () => {
      setIsVisible(true);
      clearTimeout(timeoutId);
      
      if (!isInteracting) {
        timeoutId = setTimeout(() => {
          if (!isSearchExpanded) {
            setIsVisible(false);
          }
        }, 2000); // Faster hide - more minimal
      }
    };

    const handleTouchStart = (e: TouchEvent) => {
      setLastTouchY(e.touches[0].clientY);
      isInteracting = true;
      showBar();
    };

    const handleTouchMove = (e: TouchEvent) => {
      const currentY = e.touches[0].clientY;
      const deltaY = currentY - lastTouchY;
      
      // Show bar when scrolling down from top
      if (currentY < 100 || deltaY > 5) {
        showBar();
      }
      
      setLastTouchY(currentY);
    };

    const handleTouchEnd = () => {
      isInteracting = false;
      showBar();
    };

    document.addEventListener('touchstart', handleTouchStart);
    document.addEventListener('touchmove', handleTouchMove);
    document.addEventListener('touchend', handleTouchEnd);

    // Initial timer
    showBar();

    return () => {
      clearTimeout(timeoutId);
      document.removeEventListener('touchstart', handleTouchStart);
      document.removeEventListener('touchmove', handleTouchMove);
      document.removeEventListener('touchend', handleTouchEnd);
    };
  }, [autoHide, isSearchExpanded, lastTouchY, forceHide]);

  const handleSearchClick = () => {
    setIsSearchExpanded(!isSearchExpanded);
    if (!isSearchExpanded) {
      // Focus will be set after animation completes
      setTimeout(() => {
        const input = document.getElementById('mobile-search-input');
        input?.focus();
      }, 300);
    } else {
      onSearchChange('');
    }
  };

  return (
    <motion.div
      initial={{ y: 0 }}
      animate={{ y: isVisible ? 0 : -60 }}
      transition={{ duration: 0.3, ease: 'easeInOut' }}
      className="fixed top-0 left-0 right-0 z-40 h-12"
    >
      <div className="absolute inset-0 bg-black/60 backdrop-blur-md border-b border-white/5" />
      
      <div className="relative h-full flex items-center justify-between px-4">
        {/* Filter Button */}
        <button
          onClick={onFilterClick}
          className="p-2 -ml-2 rounded-lg active:bg-white/10 transition-colors"
          aria-label="Filter"
        >
          <Funnel className="w-5 h-5 text-white/80" />
        </button>

        {/* Search Section */}
        <div className="flex items-center">
          <AnimatePresence mode="wait">
            {isSearchExpanded ? (
              <motion.div
                key="search-expanded"
                initial={{ width: 0, opacity: 0 }}
                animate={{ width: 'auto', opacity: 1 }}
                exit={{ width: 0, opacity: 0 }}
                transition={{ duration: 0.3 }}
                className="flex items-center"
              >
                <input
                  id="mobile-search-input"
                  type="search"
                  value={searchQuery}
                  onChange={(e) => onSearchChange(e.target.value)}
                  placeholder="SEARCH"
                  className="w-[200px] bg-white/10 rounded-full px-4 py-1.5 text-sm font-mono uppercase text-white placeholder-white/40 focus:outline-none focus:bg-white/15"
                />
                <button
                  onClick={handleSearchClick}
                  className="ml-2 p-2 rounded-lg active:bg-white/10 transition-colors"
                  aria-label="Close search"
                >
                  <X className="w-5 h-5 text-white/80" />
                </button>
              </motion.div>
            ) : (
              <motion.button
                key="search-collapsed"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                exit={{ opacity: 0 }}
                onClick={handleSearchClick}
                className="p-2 -mr-2 rounded-lg active:bg-white/10 transition-colors"
                aria-label="Search"
              >
                <MagnifyingGlass className="w-5 h-5 text-white/80" />
              </motion.button>
            )}
          </AnimatePresence>
        </div>
      </div>
    </motion.div>
  );
}
</file>

<file path="components/mobile/UltraMinimalSearch.tsx">
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'phosphor-react';

interface UltraMinimalSearchProps {
  isOpen: boolean;
  onClose: () => void;
  value: string;
  onChange: (value: string) => void;
}

export default function UltraMinimalSearch({
  isOpen,
  onClose,
  value,
  onChange
}: UltraMinimalSearchProps) {
  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          className="fixed inset-0 z-50 bg-black/95 backdrop-blur-md"
        >
          <div className="flex items-center h-12 px-4 border-b border-white/10">
            <input
              type="search"
              value={value}
              onChange={(e) => onChange(e.target.value)}
              placeholder="SEARCH"
              className="flex-1 bg-transparent text-sm font-mono uppercase text-white placeholder-white/30 focus:outline-none"
              autoFocus
            />
            <button
              onClick={onClose}
              className="p-2 -mr-2"
            >
              <X className="w-4 h-4 text-white/60" />
            </button>
          </div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
</file>

<file path="components/BottomControls.tsx">
'use client';

import { Maximize2 } from 'lucide-react';

interface BottomControlsProps {
  itemCount: number;
  onExpandClick: () => void;
}

export default function BottomControls({ itemCount, onExpandClick }: BottomControlsProps) {
  return (
    <div className="fixed bottom-0 left-40 right-80 h-16 bg-black/80 backdrop-blur-sm border-t border-white/10 z-30">
      <div className="h-full px-6 flex items-center justify-between">
        {/* Results Count */}
        <div className="font-mono text-white/60 text-xs uppercase tracking-[0.08em]">
          {itemCount} results
        </div>

        {/* Expand Button */}
        <button
          onClick={onExpandClick}
          className="flex items-center gap-2 px-4 py-2 bg-white/10 hover:bg-white/20 rounded-full transition-colors group"
          aria-label="Expand image"
        >
          <span className="font-mono text-white/80 group-hover:text-white text-xs uppercase tracking-[0.08em]">
            EXPAND
          </span>
          <Maximize2 size={14} className="text-white/60 group-hover:text-white" />
        </button>

        {/* Empty right side for balance */}
        <div className="w-20" />
      </div>
    </div>
  );
}
</file>

<file path="components/ImageFullscreenModal.tsx">
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { X } from 'phosphor-react';
import { useEffect } from 'react';

interface MenuItem {
  id?: number;
  image: string;
  title: string;
  description: string;
}

interface ImageFullscreenModalProps {
  isOpen: boolean;
  onClose: () => void;
  item: MenuItem | null;
}

export default function ImageFullscreenModal({ isOpen, onClose, item }: ImageFullscreenModalProps) {
  // Handle ESC key to close modal
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      // Prevent body scroll
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = 'unset';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose]);

  if (!item) return null;

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.3 }}
          className="fixed inset-0 z-50 bg-black/95 backdrop-blur-sm"
          onClick={onClose}
        >
          {/* Close Button */}
          <button
            onClick={onClose}
            className="absolute top-6 right-6 z-60 w-12 h-12 bg-black/50 backdrop-blur-md rounded-full hover:bg-black/70 transition-all duration-200 flex items-center justify-center group"
            aria-label="Close fullscreen image"
          >
            <X className="w-6 h-6 text-white/80 group-hover:text-white" />
          </button>

          {/* Image Container */}
          <div className="absolute inset-0 flex items-center justify-center p-12">
            <motion.div
              initial={{ scale: 0.9, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              exit={{ scale: 0.9, opacity: 0 }}
              transition={{ duration: 0.3, ease: "easeOut" }}
              className="relative max-w-5xl max-h-full"
              onClick={(e) => e.stopPropagation()}
            >
              {/* Image */}
              <img
                src={item.image}
                alt={item.title}
                className="max-w-full max-h-full object-contain rounded-lg shadow-2xl"
                loading="eager"
              />

              {/* Image Info Overlay */}
              <motion.div
                initial={{ y: 20, opacity: 0 }}
                animate={{ y: 0, opacity: 1 }}
                transition={{ delay: 0.2, duration: 0.3 }}
                className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 via-black/40 to-transparent rounded-b-lg p-6"
              >
                <h2 className="font-mono text-white text-lg font-medium mb-2">
                  {item.title}
                </h2>
                <p className="font-mono text-white/70 text-sm leading-relaxed line-clamp-3">
                  {item.description}
                </p>
              </motion.div>
            </motion.div>
          </div>

          {/* Instructions */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            transition={{ delay: 0.5, duration: 0.3 }}
            className="absolute bottom-6 left-1/2 -translate-x-1/2"
          >
            <p className="font-mono text-xs text-white/40 uppercase tracking-wider">
              Press ESC or click anywhere to close
            </p>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}
</file>

<file path="components/ImageModal.tsx">
'use client';

import { useEffect } from 'react';
import { X } from 'lucide-react';

interface ImageModalProps {
  isOpen: boolean;
  imageUrl?: string;
  title?: string;
  onClose: () => void;
}

export default function ImageModal({ isOpen, imageUrl, title, onClose }: ImageModalProps) {
  useEffect(() => {
    const handleEscape = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('keydown', handleEscape);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('keydown', handleEscape);
      document.body.style.overflow = '';
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return (
    <div 
      className="fixed inset-0 z-[100] bg-black/95 backdrop-blur-md flex items-center justify-center p-8"
      onClick={onClose}
    >
      {/* Close Button */}
      <button
        onClick={onClose}
        className="absolute top-6 right-6 text-white/60 hover:text-white transition-colors"
        aria-label="Close modal"
      >
        <X size={24} />
      </button>

      {/* Image Container */}
      <div 
        className="relative max-w-full max-h-full flex items-center justify-center"
        onClick={(e) => e.stopPropagation()}
      >
        {imageUrl ? (
          <img
            src={imageUrl}
            alt={title || 'Expanded view'}
            className="max-w-full max-h-[90vh] object-contain"
          />
        ) : (
          <div className="w-96 h-96 bg-white/10 rounded-lg flex items-center justify-center">
            <span className="font-mono text-white/40 text-sm uppercase tracking-[0.08em]">
              No image available
            </span>
          </div>
        )}
      </div>

      {/* Title */}
      {title && (
        <div className="absolute bottom-8 left-8 right-8 text-center">
          <h3 className="font-mono text-white text-sm uppercase tracking-[0.08em]">
            {title}
          </h3>
        </div>
      )}
    </div>
  );
}
</file>

<file path="components/MobileFilterModal.tsx">
'use client';

import { X } from 'lucide-react';

interface MobileFilterModalProps {
  isOpen: boolean;
  categories: string[];
  selectedCategories: string[];
  onCategoryToggle: (category: string) => void;
  onClose: () => void;
}

const CATEGORY_ORDER = [
  'ALL',
  'PAYMENTS', 
  'TRADING',
  'AGENTS',
  'SOCIAL',
  'IDENTITY',
  'MESSAGING',
  'GATING',
  'PRIVACY',
  'REWARDS',
  'ART',
  'INVEST',
  'WALLET'
];

export default function MobileFilterModal({ 
  isOpen,
  categories, 
  selectedCategories, 
  onCategoryToggle,
  onClose 
}: MobileFilterModalProps) {
  
  if (!isOpen) return null;

  const isAllSelected = selectedCategories.length === 0;
  
  const sortedCategories = [...categories].sort((a, b) => {
    const aIndex = CATEGORY_ORDER.indexOf(a.toUpperCase());
    const bIndex = CATEGORY_ORDER.indexOf(b.toUpperCase());
    
    if (aIndex === -1 && bIndex === -1) return a.localeCompare(b);
    if (aIndex === -1) return 1;
    if (bIndex === -1) return -1;
    return aIndex - bIndex;
  });

  const handleAllClick = () => {
    if (!isAllSelected && selectedCategories.length > 0) {
      selectedCategories.forEach(cat => onCategoryToggle(cat));
    }
    onClose();
  };

  return (
    <div className="fixed inset-0 z-[60] bg-black md:hidden">
      {/* Header */}
      <div className="flex items-center justify-between p-4 border-b border-white/10">
        <h2 className="font-mono text-white uppercase text-sm tracking-[0.08em]">
          FILTER
        </h2>
        <button
          onClick={onClose}
          className="text-white/60 hover:text-white transition-colors"
          aria-label="Close filters"
        >
          <X size={20} />
        </button>
      </div>

      {/* Filter List */}
      <div className="p-4 space-y-3 overflow-y-auto" style={{ maxHeight: 'calc(100vh - 64px)' }}>
        {/* ALL button */}
        <button
          onClick={handleAllClick}
          className="relative block w-full text-left"
        >
          {isAllSelected && (
            <div className="absolute left-0 top-1/2 -translate-y-1/2 w-4 h-[1px] bg-white" />
          )}
          <span 
            className={`
              font-mono uppercase text-sm transition-all duration-200
              ${isAllSelected 
                ? 'text-white tracking-[0.08em] pl-6' 
                : 'text-white/60 tracking-normal'
              }
            `}
          >
            ALL
          </span>
        </button>

        {/* Category buttons */}
        {sortedCategories.map((category) => {
          const isActive = selectedCategories.includes(category);
          
          return (
            <button
              key={category}
              onClick={() => {
                onCategoryToggle(category);
              }}
              className="relative block w-full text-left"
            >
              {isActive && (
                <div className="absolute left-0 top-1/2 -translate-y-1/2 w-4 h-[1px] bg-white" />
              )}
              <span 
                className={`
                  font-mono uppercase text-sm transition-all duration-200
                  ${isActive 
                    ? 'text-white tracking-[0.08em] pl-6' 
                    : 'text-white/60 tracking-normal'
                  }
                `}
              >
                {category}
              </span>
            </button>
          );
        })}
      </div>

      {/* Apply Button */}
      <div className="absolute bottom-0 left-0 right-0 p-4 bg-black border-t border-white/10">
        <button
          onClick={onClose}
          className="w-full py-3 bg-white text-black font-mono uppercase text-xs tracking-[0.08em] text-center"
        >
          APPLY FILTERS
        </button>
      </div>
    </div>
  );
}
</file>

<file path="hooks/useAutoHide.ts">
import { useState, useEffect, useCallback, useRef } from 'react';

interface UseAutoHideOptions {
  delay?: number;
  enabled?: boolean;
  onHide?: () => void;
  onShow?: () => void;
}

export function useAutoHide({
  delay = 3000,
  enabled = true,
  onHide,
  onShow
}: UseAutoHideOptions = {}) {
  const [isVisible, setIsVisible] = useState(true);
  const timeoutRef = useRef<NodeJS.Timeout | null>(null);
  const lastActivityRef = useRef<number>(Date.now());

  const clearHideTimeout = useCallback(() => {
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current);
      timeoutRef.current = null;
    }
  }, []);

  const resetTimer = useCallback(() => {
    if (!enabled) return;
    
    clearHideTimeout();
    lastActivityRef.current = Date.now();
    
    if (!isVisible) {
      setIsVisible(true);
      onShow?.();
    }
    
    timeoutRef.current = setTimeout(() => {
      setIsVisible(false);
      onHide?.();
    }, delay);
  }, [enabled, delay, isVisible, clearHideTimeout, onHide, onShow]);

  const show = useCallback(() => {
    setIsVisible(true);
    onShow?.();
    resetTimer();
  }, [resetTimer, onShow]);

  const hide = useCallback(() => {
    clearHideTimeout();
    setIsVisible(false);
    onHide?.();
  }, [clearHideTimeout, onHide]);

  const toggle = useCallback(() => {
    if (isVisible) {
      hide();
    } else {
      show();
    }
  }, [isVisible, hide, show]);

  // Set up activity listeners
  useEffect(() => {
    if (!enabled) {
      setIsVisible(true);
      return;
    }

    const handleActivity = () => {
      resetTimer();
    };

    // Listen for user activity
    const events = ['mousemove', 'touchstart', 'touchmove', 'click', 'keydown'];
    events.forEach(event => {
      document.addEventListener(event, handleActivity);
    });

    // Initial timer
    resetTimer();

    return () => {
      clearHideTimeout();
      events.forEach(event => {
        document.removeEventListener(event, handleActivity);
      });
    };
  }, [enabled, resetTimer, clearHideTimeout]);

  return {
    isVisible,
    show,
    hide,
    toggle,
    resetTimer
  };
}
</file>

<file path="hooks/useMediaQuery.ts">
import { useState, useEffect } from 'react';

export function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    const media = window.matchMedia(query);
    if (media.matches !== matches) {
      setMatches(media.matches);
    }
    
    const listener = (e: MediaQueryListEvent) => setMatches(e.matches);
    media.addEventListener('change', listener);
    
    return () => media.removeEventListener('change', listener);
  }, [matches, query]);

  return matches;
}
</file>

<file path="lib/format.ts">
/**
 * Format utilities for consistent data display
 */

/**
 * Format a date string to uppercase short format (e.g., "MAR 23, 2023")
 */
export function formatMintDate(dateString?: string | null): string {
  if (!dateString) return 'DATE UNKNOWN';
  
  try {
    const parsedDate = new Date(dateString);
    if (isNaN(parsedDate.getTime())) {
      return 'DATE UNKNOWN';
    }
    
    return parsedDate.toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric', 
      year: 'numeric' 
    }).toUpperCase();
  } catch {
    return 'DATE UNKNOWN';
  }
}

/**
 * Format a hash/address for display (e.g., "0x1234...abcd")
 */
export function formatHash(address?: string): string {
  if (!address) return '';
  if (address.length <= 12) return address;
  return `${address.slice(0, 6)}...${address.slice(-6)}`;
}

/**
 * Get the appropriate block explorer URL for a given network
 */
export function getBlockExplorerUrl(address?: string, network?: string): string {
  if (!address) return '#';
  
  const key = (network ?? '').toUpperCase();
  const explorers: Record<string, string> = {
    'ETHEREUM-MAINNET': 'https://etherscan.io/address/',
    'ETHEREUM-SEPOLIA': 'https://sepolia.etherscan.io/address/',
    'ZORA-MAINNET': 'https://explorer.zora.energy/address/',
    'ZORA-SEPOLIA': 'https://sepolia.explorer.zora.energy/address/',
  };
  
  const base = explorers[key];
  return base ? base + address : '#';
}
</file>

<file path="lib/staticTypes.ts">
// Auto-generated types for static NFT data
// Generated at: 2025-09-04T16:05:58.254Z

export interface StaticNFTData {
  items: NFTToken[];
  categories: string[];
  metadata: {
    totalCount: number;
    generatedAt: string;
    version: string;
  };
}

export interface NFTToken {
  id: number;
  token_id: string;
  title: string | null;
  description: string | null;
  image_url: string | null;
  original_url: string | null;
  mint_url: string | null;
  network: string | null;
  collection_address: string | null;
  mime_type: string | null;
  downloadable_uri: string | null;
  raw_metadata: Record<string, unknown> | null;
  created_at: string | null;
  updated_at: string | null;
  embedding: number[] | null;
  thumbnail_url: string | null;
  category: string[] | null;
  primary_category: string | null;
  subcat: string | null;
}
</file>

<file path="migrations/001_improved_categorization.sql">
-- Migration: Improved Categorization System
-- Date: 2025-08-05
-- Purpose: Implement 15-category system with confidence scoring and better classification

-- ============================================
-- STEP 1: BACKUP CURRENT DATA
-- ============================================

-- Create backup of current categories (if not exists)
CREATE TABLE IF NOT EXISTS public.nft_tokens_category_backup_v2 AS
SELECT 
    id, 
    token_id,
    title,
    description,
    category,
    text_first_category,
    image_first_category,
    CURRENT_TIMESTAMP as backed_up_at
FROM public.nft_tokens;

-- ============================================
-- STEP 2: ADD NEW COLUMNS
-- ============================================

-- Add new columns for improved categorization
ALTER TABLE public.nft_tokens 
ADD COLUMN IF NOT EXISTS category_v2 text[],
ADD COLUMN IF NOT EXISTS confidence_score float DEFAULT 0.0,
ADD COLUMN IF NOT EXISTS needs_review boolean DEFAULT false,
ADD COLUMN IF NOT EXISTS subcategory text,
ADD COLUMN IF NOT EXISTS categorized_at timestamp DEFAULT CURRENT_TIMESTAMP;

-- ============================================
-- STEP 3: CREATE CLASSIFICATION FUNCTIONS
-- ============================================

-- Function: Classify with new 15-category system
CREATE OR REPLACE FUNCTION public.classify_all_categories_v2(
    title text,
    description text
) RETURNS text[]
LANGUAGE plpgsql
AS $$
DECLARE
    categories text[] := ARRAY[]::text[];
    combined_text text;
BEGIN
    -- Combine and normalize text
    combined_text := LOWER(COALESCE(title, '') || ' ' || COALESCE(description, ''));
    
    -- DEFI Category
    IF combined_text ~ '\m(defi|yield|lending|liquidity|amm|vault|farm|staking|compound|aave|curve|pool)\M' THEN
        categories := array_append(categories, 'defi');
    END IF;
    
    -- TRADING Category (NFT/token trading, not DeFi)
    IF combined_text ~ '\m(swap|trade|trading|exchange|market|buy|sell|order|dex|listing|floor|sweep|bulk swap|swap everything|swap boost|trading coach)\M' 
       AND 'defi' != ALL(categories) THEN
        categories := array_append(categories, 'trading');
    END IF;
    
    -- PAYMENTS Category
    IF combined_text ~ '\m(payment|pay|checkout|invoice|receipt|transaction|purchase|credit card|bitcoin|apple cash|streaming payment|instant checkout)\M' THEN
        categories := array_append(categories, 'payments');
    END IF;
    
    -- SOCIAL Category
    IF combined_text ~ '\m(social|friend|follow|profile|community|network|feed|timeline|share|post|vitalik|people to follow)\M' THEN
        categories := array_append(categories, 'social');
    END IF;
    
    -- MESSAGING Category
    IF combined_text ~ '\m(message|messaging|chat|dm|inbox|notification|reply|comment|broadcast|chat bubble|chat ticker)\M' THEN
        categories := array_append(categories, 'messaging');
    END IF;
    
    -- IDENTITY Category (includes former PFP)
    IF combined_text ~ '\m(identity|profile|avatar|pfp|reputation|credential|badge|verification|kyc|did|ens|lens|wrapped|onions app)\M' THEN
        categories := array_append(categories, 'identity');
    END IF;
    
    -- PRIVACY Category (includes former security)
    IF combined_text ~ '\m(privacy|private|anonymous|security|encryption|secure|protection|vpn|incognito|tumbler|security alert)\M' THEN
        categories := array_append(categories, 'privacy');
    END IF;
    
    -- GATING Category
    IF combined_text ~ '\m(gate|gating|gated|access|membership|subscription|paywall|token gate|exclusive|whitelist|allowlist|claim)\M' THEN
        categories := array_append(categories, 'gating');
    END IF;
    
    -- CREATORS Category (replaces art)
    IF combined_text ~ '\m(art|artist|creator|create|mint|nft|collection|gallery|creative|design|music|content|physical art|shotgun mint)\M' THEN
        categories := array_append(categories, 'creators');
    END IF;
    
    -- GAMING Category (NEW)
    IF combined_text ~ '\m(game|gaming|play|bet|betting|gamble|casino|lottery|prediction|polymarket|double or nothing|treasure hunt)\M' THEN
        categories := array_append(categories, 'gaming');
    END IF;
    
    -- TOOLS Category (NEW - for utilities)
    IF combined_text ~ '\m(tool|utility|explorer|tracker|analytics|monitor|dashboard|calculator|converter|export|import|translator|generator)\M' THEN
        categories := array_append(categories, 'tools');
    END IF;
    
    -- AGENTS Category (more focused)
    IF combined_text ~ '\m(agent|ai|llm|gpt|bot|automated|assistant|smart contract agent|phanny|instruct|model selection)\M' THEN
        categories := array_append(categories, 'agents');
    END IF;
    
    -- REWARDS Category
    IF combined_text ~ '\m(reward|airdrop|points|loyalty|incentive|earn|mining|faucet|bounty|bounties|sharehold to earn)\M' THEN
        categories := array_append(categories, 'rewards');
    END IF;
    
    -- DATA Category (NEW)
    IF combined_text ~ '\m(data|storage|record|database|index|archive|backup|history|log|tracking|medical record)\M' THEN
        categories := array_append(categories, 'data');
    END IF;
    
    -- INFRASTRUCTURE Category (NEW - for dev tools)
    IF combined_text ~ '\m(infrastructure|protocol|sdk|api|library|framework|development|deploy|contract|erc|eip|launch l2)\M' THEN
        categories := array_append(categories, 'infrastructure');
    END IF;
    
    -- Return empty array if no matches (avoid defaulting to wallet)
    RETURN categories;
END;
$$;

-- Function: Calculate confidence score
CREATE OR REPLACE FUNCTION public.calculate_confidence_score(
    title text,
    description text,
    categories text[]
) RETURNS float
LANGUAGE plpgsql
AS $$
DECLARE
    confidence float := 0.0;
    word_count int;
    match_strength float;
    combined_text text;
BEGIN
    -- Base confidence from number of categories found
    IF array_length(categories, 1) > 0 THEN
        -- Start with base confidence
        confidence := 0.5;
        
        -- Boost for clear matches
        combined_text := LOWER(COALESCE(title, '') || ' ' || COALESCE(description, ''));
        
        -- Count total words for context
        word_count := array_length(string_to_array(combined_text, ' '), 1);
        
        -- Add confidence for specific category matches
        IF array_length(categories, 1) = 1 THEN
            -- Single category is often more confident
            confidence := confidence + 0.3;
        ELSIF array_length(categories, 1) = 2 THEN
            -- Two categories is reasonable
            confidence := confidence + 0.2;
        ELSIF array_length(categories, 1) > 3 THEN
            -- Too many categories reduces confidence
            confidence := confidence - 0.1;
        END IF;
        
        -- Boost confidence for longer, more descriptive text
        IF word_count > 5 THEN
            confidence := confidence + 0.1;
        END IF;
        
        -- Ensure confidence is between 0 and 1
        confidence := LEAST(GREATEST(confidence, 0.0), 1.0);
    ELSE
        -- No categories found - low confidence
        confidence := 0.1;
    END IF;
    
    RETURN confidence;
END;
$$;

-- Function: Reclassify wallet defaults
CREATE OR REPLACE FUNCTION public.reclassify_wallet_defaults(
    title text,
    description text,
    current_categories text[]
) RETURNS text[]
LANGUAGE plpgsql
AS $$
DECLARE
    new_categories text[];
    combined_text text;
BEGIN
    -- If only category is 'wallet' or no categories, try to reclassify
    IF current_categories IS NULL OR 
       array_length(current_categories, 1) = 0 OR
       (array_length(current_categories, 1) = 1 AND current_categories[1] = 'wallet') THEN
        
        combined_text := LOWER(COALESCE(title, '') || ' ' || COALESCE(description, ''));
        
        -- Check for specific patterns that were miscategorized
        
        -- UI/UX elements -> tools
        IF combined_text ~ '\m(button|menu|tab|interface|ui|ux|widget|component|frame|gesture)\M' THEN
            RETURN ARRAY['tools'];
        END IF;
        
        -- Entertainment -> gaming
        IF combined_text ~ '\m(astrology|horoscope|ringtone|music|video|movie|show|entertainment)\M' THEN
            RETURN ARRAY['gaming'];
        END IF;
        
        -- Communication -> messaging or social
        IF combined_text ~ '\m(notification|alert|ping|buzz|ring|call|phone)\M' THEN
            RETURN ARRAY['messaging'];
        END IF;
        
        -- Settings/preferences -> tools
        IF combined_text ~ '\m(setting|preference|config|option|control|mode)\M' THEN
            RETURN ARRAY['tools'];
        END IF;
        
        -- Questions/support -> tools
        IF combined_text ~ '\m(question|help|support|faq|guide|tutorial|tip)\M' THEN
            RETURN ARRAY['tools'];
        END IF;
        
        -- Otherwise, run the new classifier
        new_categories := public.classify_all_categories_v2(title, description);
        
        -- If still no categories, mark as tools (better than wallet)
        IF array_length(new_categories, 1) = 0 THEN
            RETURN ARRAY['tools'];
        END IF;
        
        RETURN new_categories;
    END IF;
    
    -- Keep existing categories if they're not just wallet
    RETURN current_categories;
END;
$$;

-- Function: Determine primary category from multi-label
CREATE OR REPLACE FUNCTION public.determine_primary_category(
    categories text[]
) RETURNS text
LANGUAGE plpgsql
AS $$
DECLARE
    priority_order text[] := ARRAY['defi', 'payments', 'trading', 'agents', 'gaming', 
                                   'creators', 'social', 'identity', 'messaging', 
                                   'gating', 'privacy', 'rewards', 'data', 
                                   'infrastructure', 'tools'];
    cat text;
BEGIN
    -- Return first category in priority order
    FOREACH cat IN ARRAY priority_order LOOP
        IF cat = ANY(categories) THEN
            RETURN cat;
        END IF;
    END LOOP;
    
    -- If no priority match, return first category
    IF array_length(categories, 1) > 0 THEN
        RETURN categories[1];
    END IF;
    
    -- Default to tools if nothing else
    RETURN 'tools';
END;
$$;

-- ============================================
-- STEP 4: RUN INITIAL CLASSIFICATION
-- ============================================

-- First, reclassify all items with the new system
UPDATE public.nft_tokens n
SET 
    category_v2 = COALESCE(
        public.reclassify_wallet_defaults(n.title, n.description, n.category),
        public.classify_all_categories_v2(n.title, n.description)
    ),
    confidence_score = public.calculate_confidence_score(
        n.title, 
        n.description, 
        COALESCE(
            public.reclassify_wallet_defaults(n.title, n.description, n.category),
            public.classify_all_categories_v2(n.title, n.description)
        )
    ),
    needs_review = CASE 
        WHEN public.calculate_confidence_score(
            n.title, 
            n.description, 
            COALESCE(
                public.reclassify_wallet_defaults(n.title, n.description, n.category),
                public.classify_all_categories_v2(n.title, n.description)
            )
        ) < 0.5 THEN true
        ELSE false
    END,
    subcategory = public.determine_primary_category(
        COALESCE(
            public.reclassify_wallet_defaults(n.title, n.description, n.category),
            public.classify_all_categories_v2(n.title, n.description)
        )
    ),
    categorized_at = CURRENT_TIMESTAMP
FROM public.nft_tokens_filtered f
WHERE n.id = f.id;

-- ============================================
-- STEP 5: CREATE ANALYSIS VIEWS
-- ============================================

-- View: Category distribution
CREATE OR REPLACE VIEW public.category_distribution_v2 AS
SELECT 
    unnest(category_v2) as category,
    COUNT(*) as item_count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as percentage
FROM public.nft_tokens_filtered
WHERE category_v2 IS NOT NULL AND array_length(category_v2, 1) > 0
GROUP BY 1
ORDER BY 2 DESC;

-- View: Items needing review
CREATE OR REPLACE VIEW public.items_needing_review AS
SELECT 
    id,
    token_id,
    title,
    category_v2,
    confidence_score,
    category as old_category
FROM public.nft_tokens_filtered
WHERE needs_review = true
ORDER BY confidence_score ASC;

-- View: Comparison of old vs new categories
CREATE OR REPLACE VIEW public.category_comparison AS
SELECT 
    id,
    token_id,
    title,
    category as old_categories,
    category_v2 as new_categories,
    confidence_score
FROM public.nft_tokens_filtered
WHERE category IS DISTINCT FROM category_v2
ORDER BY confidence_score DESC;

-- ============================================
-- STEP 6: REPORT RESULTS
-- ============================================

-- Show distribution of new categories
SELECT * FROM public.category_distribution_v2;

-- Show items that need manual review
SELECT COUNT(*) as items_needing_review 
FROM public.items_needing_review;

-- Show improvement metrics
SELECT 
    'Old System' as system,
    COUNT(CASE WHEN category IS NULL OR array_length(category, 1) = 0 THEN 1 END) as uncategorized,
    COUNT(CASE WHEN array_length(category, 1) = 1 AND category[1] = 'wallet' THEN 1 END) as wallet_defaults
FROM public.nft_tokens_filtered
UNION ALL
SELECT 
    'New System' as system,
    COUNT(CASE WHEN category_v2 IS NULL OR array_length(category_v2, 1) = 0 THEN 1 END) as uncategorized,
    COUNT(CASE WHEN array_length(category_v2, 1) = 1 AND category_v2[1] = 'tools' THEN 1 END) as tool_defaults
FROM public.nft_tokens_filtered;
</file>

<file path="migrations/003_enhanced_search.sql">
-- Enhanced Search Improvements: Multi-signal search with synonyms and visual labels
-- Date: 2025-08-08
-- Purpose: Fix search to find semantically and visually relevant items

-- ============================================
-- STEP 1: ADD IMAGE LABELS COLUMN
-- ============================================

ALTER TABLE public.nft_tokens 
ADD COLUMN IF NOT EXISTS image_labels text[];

-- ============================================
-- STEP 2: CREATE SYNONYM MAPPING TABLE
-- ============================================

CREATE TABLE IF NOT EXISTS public.search_synonyms (
  id serial PRIMARY KEY,
  term text NOT NULL,
  synonyms text[] NOT NULL,
  domain text,
  created_at timestamp DEFAULT CURRENT_TIMESTAMP,
  UNIQUE(term)
);

CREATE INDEX IF NOT EXISTS idx_search_synonyms_term 
ON public.search_synonyms(term);

-- ============================================
-- STEP 3: UPDATE SEARCH VECTOR WITH IMAGE LABELS
-- ============================================

-- Drop existing column if it exists
ALTER TABLE public.nft_tokens 
DROP COLUMN IF EXISTS search_vector;

-- Recreate with image_labels included
ALTER TABLE public.nft_tokens
ADD COLUMN search_vector tsvector
GENERATED ALWAYS AS (
  setweight(to_tsvector('english', unaccent(coalesce(title, ''))), 'A') ||
  setweight(to_tsvector('english', unaccent(coalesce(description, ''))), 'B') ||
  setweight(to_tsvector('simple', array_to_string(coalesce(category, '{}')::text[], ' ')), 'A') ||
  setweight(to_tsvector('simple', array_to_string(coalesce(image_labels, '{}')::text[], ' ')), 'A')
) STORED;

-- Recreate index
CREATE INDEX IF NOT EXISTS idx_nft_tokens_search_vector 
ON public.nft_tokens USING gin(search_vector);

-- ============================================
-- STEP 4: ADD TRIGRAM INDEX ON DESCRIPTION
-- ============================================

CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE INDEX IF NOT EXISTS idx_nft_tokens_description_trgm 
ON public.nft_tokens USING gin (description gin_trgm_ops);

-- ============================================
-- STEP 5: CREATE ENHANCED RPC FUNCTION
-- ============================================

CREATE OR REPLACE FUNCTION public.rpc_search_nfts_enhanced(
  q text, 
  cats text[] DEFAULT NULL
)
RETURNS SETOF public.nft_tokens_filtered
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  expanded_query text;
  synonym_terms text[];
BEGIN
  -- Query expansion with synonyms
  expanded_query := q;
  
  -- Look up synonyms for the query
  IF q IS NOT NULL AND q != '' THEN
    SELECT array_agg(DISTINCT unnest(s.synonyms))
    INTO synonym_terms
    FROM public.search_synonyms s
    WHERE LOWER(q) = ANY(array_append(s.synonyms, s.term));
    
    -- Build expanded query with OR conditions
    IF synonym_terms IS NOT NULL THEN
      expanded_query := q || ' ' || array_to_string(synonym_terms, ' ');
    END IF;
  END IF;
  
  RETURN QUERY
  SELECT n.*
  FROM public.nft_tokens_filtered n
  WHERE
    -- Category filter
    (cats IS NULL OR array_length(cats, 1) IS NULL OR n.category && cats)
    AND (
      coalesce(q, '') = ''
      OR n.search_vector @@ websearch_to_tsquery('english', unaccent(expanded_query))
      OR similarity(n.title, q) > 0.3
      OR similarity(n.description, q) > 0.25
    )
  ORDER BY
    -- FTS rank with expanded query
    ts_rank_cd(n.search_vector, websearch_to_tsquery('english', unaccent(coalesce(expanded_query, '')))) DESC,
    -- Category boost
    CASE WHEN cats IS NOT NULL AND array_length(cats, 1) IS NOT NULL AND n.category && cats THEN 1 ELSE 0 END DESC,
    -- Fuzzy similarity on title
    similarity(n.title, coalesce(q, '')) DESC NULLS LAST,
    -- Fuzzy similarity on description
    similarity(n.description, coalesce(q, '')) DESC NULLS LAST,
    -- Deterministic fallback
    n.id ASC
  LIMIT 200;
END;
$$;

-- Grant permissions
GRANT EXECUTE ON FUNCTION public.rpc_search_nfts_enhanced(text, text[]) TO anon, authenticated;

-- ============================================
-- STEP 6: POPULATE INITIAL SYNONYMS
-- ============================================

INSERT INTO public.search_synonyms (term, synonyms, domain) VALUES
-- Footwear domain
('sneakers', ARRAY['shoes', 'kicks', 'footwear', 'trainers', 'runners', 'snkrs'], 'footwear'),
('shoes', ARRAY['sneakers', 'kicks', 'footwear', 'trainers', 'runners'], 'footwear'),
('nike', ARRAY['swoosh', 'jordan', 'air max', 'snkrs'], 'brands'),
('adidas', ARRAY['three stripes', 'yeezy', 'boost', 'ultraboost'], 'brands'),

-- Crypto/DeFi domain
('swap', ARRAY['exchange', 'trade', 'convert', 'dex'], 'defi'),
('defi', ARRAY['decentralized finance', 'yield', 'farming', 'liquidity', 'amm'], 'defi'),
('nft', ARRAY['non-fungible token', 'collectible', 'digital art', 'pfp'], 'nft'),

-- Social domain
('social', ARRAY['community', 'network', 'friends', 'followers', 'connections'], 'social'),
('message', ARRAY['chat', 'dm', 'messaging', 'conversation', 'communication'], 'messaging'),

-- Gaming domain
('game', ARRAY['gaming', 'play', 'gamefi', 'p2e', 'play to earn'], 'gaming'),
('bet', ARRAY['betting', 'gamble', 'wager', 'prediction', 'odds'], 'gaming')

ON CONFLICT (term) DO UPDATE
SET synonyms = EXCLUDED.synonyms,
    domain = EXCLUDED.domain;

-- ============================================
-- STEP 7: POPULATE SOME INITIAL IMAGE LABELS
-- ============================================

-- Example: Add labels for known sneaker-related items
UPDATE public.nft_tokens
SET image_labels = ARRAY['sneakers', 'footwear', 'shoes']
WHERE id IN (603, 724, 687)
  AND image_labels IS NULL;

-- Add labels for items with sneaker brands in title/description
UPDATE public.nft_tokens
SET image_labels = array_append(coalesce(image_labels, '{}'), 'sneakers')
WHERE (
  title ~* '\m(nike|adidas|jordan|yeezy|air max|boost)\M'
  OR description ~* '\m(nike|adidas|jordan|yeezy|air max|boost)\M'
)
AND NOT ('sneakers' = ANY(coalesce(image_labels, '{}')));
</file>

<file path="migrations/004_fix_filtered_view.sql">
-- Fix the filtered view to only show the two allowed Zora collections
-- This restores the original filtering behavior

CREATE OR REPLACE VIEW public.nft_tokens_filtered AS
SELECT n.*
FROM public.nft_tokens n
WHERE n.collection_address IN (
  '0x5908eb01497b5d8e53c339ea0186050d487c8d0c',  -- Ethereum mainnet collection (334 items)
  '0x5abf0c04ab7196e2bdd19313b479baebd9f7791b'   -- Zora mainnet collection (372 items)
);

-- This view should return 706 items total (334 + 372)
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="types/global.d.ts">
declare module 'node-fetch';
declare module 'file-type';
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="components/FilterSidebar.tsx">
'use client';

interface FilterSidebarProps {
  categories: string[];
  selectedCategories: string[];
  onCategoryToggle: (category: string) => void;
}

const CATEGORY_ORDER = [
  'ALL',
  'PAYMENTS', 
  'TRADING',
  'AGENTS',
  'SOCIAL',
  'IDENTITY',
  'MESSAGING',
  'GATING',
  'PRIVACY',
  'REWARDS',
  'ART',
  'INVEST',
  'WALLET'
];

export default function FilterSidebar({ 
  categories, 
  selectedCategories, 
  onCategoryToggle 
}: FilterSidebarProps) {
  
  const isAllSelected = selectedCategories.length === 0;
  
  // Sort categories based on predefined order
  const sortedCategories = [...categories].sort((a, b) => {
    const aIndex = CATEGORY_ORDER.indexOf(a.toUpperCase());
    const bIndex = CATEGORY_ORDER.indexOf(b.toUpperCase());
    
    if (aIndex === -1 && bIndex === -1) return a.localeCompare(b);
    if (aIndex === -1) return 1;
    if (bIndex === -1) return -1;
    return aIndex - bIndex;
  });

  const handleAllClick = () => {
    // Clear all selections to show all items
    if (!isAllSelected && selectedCategories.length > 0) {
      selectedCategories.forEach(cat => onCategoryToggle(cat));
    }
  };

  return (
    <aside className="fixed left-0 top-16 bottom-0 w-40 bg-black border-r border-white/10 z-40 overflow-y-auto">
      <div className="p-6">
        <div className="space-y-3">
          {/* ALL button */}
          <button
            onClick={handleAllClick}
            className="relative block w-full text-left group"
          >
            {isAllSelected && (
              <div className="absolute left-0 top-1/2 -translate-y-1/2 w-4 h-[1px] bg-white" />
            )}
            <span 
              className={`
                font-mono uppercase text-xs transition-all duration-200
                ${isAllSelected 
                  ? 'text-white tracking-[0.08em] pl-6' 
                  : 'text-white/60 hover:text-white/80 tracking-normal'
                }
              `}
            >
              ALL
            </span>
          </button>

          {/* Category buttons */}
          {sortedCategories.map((category) => {
            const isActive = selectedCategories.includes(category);
            
            return (
              <button
                key={category}
                onClick={() => onCategoryToggle(category)}
                className="relative block w-full text-left group"
              >
                {isActive && (
                  <div className="absolute left-0 top-1/2 -translate-y-1/2 w-4 h-[1px] bg-white" />
                )}
                <span 
                  className={`
                    font-mono uppercase text-xs transition-all duration-200
                    ${isActive 
                      ? 'text-white tracking-[0.08em] pl-6' 
                      : 'text-white/60 hover:text-white/80 tracking-normal'
                    }
                  `}
                >
                  {category}
                </span>
              </button>
            );
          })}
        </div>
      </div>
    </aside>
  );
}
</file>

<file path="components/FloatingMetadata.tsx">
'use client';

import { useState, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { formatMintDate } from '@/lib/format';
import { 
  X, 
  Heart, 
  Share2, 
  ExternalLink, 
  Calendar, 
  Hash, 
  Globe,
  ChevronDown,
  ChevronUp,
  Maximize2
} from 'lucide-react';

interface FloatingMetadataProps {
  item: {
    id?: number;
    title: string;
    description: string;
    mintUrl?: string | null;
    createdAt?: string | null;
    categories?: string[];
    network?: string | null;
    collectionAddress?: string | null;
  } | null;
  isVisible: boolean;
  onClose?: () => void;
  onExpand?: () => void;
  position?: 'top-right' | 'top-left' | 'bottom-right' | 'bottom-left';
  autoHide?: boolean;
}

type DisclosureLevel = 'minimal' | 'expanded' | 'full';

export default function FloatingMetadata({
  item,
  isVisible,
  onClose,
  onExpand,
  position = 'top-right',
  autoHide = true
}: FloatingMetadataProps) {
  const [disclosureLevel, setDisclosureLevel] = useState<DisclosureLevel>('minimal');
  const [isFavorited, setIsFavorited] = useState(false);

  const toggleDisclosure = useCallback(() => {
    setDisclosureLevel(prev => {
      if (prev === 'minimal') return 'expanded';
      if (prev === 'expanded') return 'minimal';
      return prev;
    });
  }, []);

  const handleFullView = useCallback(() => {
    setDisclosureLevel('full');
    onExpand?.();
  }, [onExpand]);

  const formatDate = (dateString: string | null | undefined) => {
    const formatted = formatMintDate(dateString);
    return formatted === 'DATE UNKNOWN' ? 'Unknown date' : formatted;
  };

  if (!item) return null;

  // Position classes based on prop
  const positionClasses = {
    'top-right': 'top-4 right-4',
    'top-left': 'top-4 left-4',
    'bottom-right': 'bottom-4 right-4',
    'bottom-left': 'bottom-4 left-4'
  };

  // Animation variants
  const cardVariants = {
    hidden: { 
      opacity: 0, 
      x: position.includes('right') ? 100 : -100,
      scale: 0.9
    },
    visible: { 
      opacity: 1, 
      x: 0,
      scale: 1,
      transition: {
        type: 'spring' as const,
        damping: 25,
        stiffness: 300
      }
    },
    exit: { 
      opacity: 0,
      x: position.includes('right') ? 100 : -100,
      scale: 0.9,
      transition: { duration: 0.2 }
    }
  };

  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          className={`fixed z-50 ${positionClasses[position]} w-[280px] md:w-[320px]`}
          variants={cardVariants}
          initial="hidden"
          animate="visible"
          exit="exit"
        >
          <div className="bg-black/80 backdrop-blur-xl rounded-2xl border border-white/10 shadow-2xl overflow-hidden">
            {/* Tier 1: Minimal View - Always Visible */}
            <div className="p-4">
              {/* Header with Title and Actions */}
              <div className="flex items-start justify-between gap-3 mb-3">
                <div className="flex-1 min-w-0">
                  <h3 className="font-mono text-sm uppercase tracking-wider text-white truncate">
                    {item.title}
                  </h3>
                  {item.categories && item.categories.length > 0 && (
                    <span className="font-mono text-xs text-white/60 uppercase">
                      {item.categories[0]}
                    </span>
                  )}
                </div>
                
                {/* Quick Actions */}
                <div className="flex items-center gap-1">
                  <button
                    onClick={() => setIsFavorited(!isFavorited)}
                    className="p-2 rounded-lg hover:bg-white/10 transition-colors"
                    aria-label="Favorite"
                  >
                    <Heart 
                      className={`w-4 h-4 ${isFavorited ? 'fill-white text-white' : 'text-white/60'}`} 
                    />
                  </button>
                  <button
                    onClick={() => navigator.share?.({ title: item.title, text: item.description })}
                    className="p-2 rounded-lg hover:bg-white/10 transition-colors"
                    aria-label="Share"
                  >
                    <Share2 className="w-4 h-4 text-white/60" />
                  </button>
                  {onClose && (
                    <button
                      onClick={onClose}
                      className="p-2 rounded-lg hover:bg-white/10 transition-colors"
                      aria-label="Close"
                    >
                      <X className="w-4 h-4 text-white/60" />
                    </button>
                  )}
                </div>
              </div>

              {/* Expand/Collapse Button */}
              <button
                onClick={toggleDisclosure}
                className="w-full flex items-center justify-center gap-2 py-2 hover:bg-white/5 rounded-lg transition-colors"
              >
                <span className="font-mono text-xs text-white/60 uppercase tracking-wider">
                  {disclosureLevel === 'minimal' ? 'More Info' : 'Less Info'}
                </span>
                {disclosureLevel === 'minimal' ? (
                  <ChevronDown className="w-3 h-3 text-white/60" />
                ) : (
                  <ChevronUp className="w-3 h-3 text-white/60" />
                )}
              </button>
            </div>

            {/* Tier 2: Expanded View - On Demand */}
            <AnimatePresence>
              {disclosureLevel === 'expanded' && (
                <motion.div
                  initial={{ height: 0, opacity: 0 }}
                  animate={{ height: 'auto', opacity: 1 }}
                  exit={{ height: 0, opacity: 0 }}
                  transition={{ duration: 0.3 }}
                  className="border-t border-white/10"
                >
                  <div className="p-4 space-y-3">
                    {/* Date */}
                    {item.createdAt && (
                      <div className="flex items-center gap-2 font-mono text-xs text-white/60">
                        <Calendar className="w-3 h-3" />
                        <time className="uppercase">{formatDate(item.createdAt)}</time>
                      </div>
                    )}

                    {/* Description Preview */}
                    <p className="font-mono text-xs text-white/80 leading-relaxed line-clamp-3">
                      {item.description}
                    </p>

                    {/* All Categories */}
                    {item.categories && item.categories.length > 1 && (
                      <div className="flex flex-wrap gap-2">
                        {item.categories.slice(1).map((cat, idx) => (
                          <span 
                            key={idx}
                            className="px-2 py-1 bg-white/10 rounded-full font-mono text-xs uppercase text-white/60"
                          >
                            {cat}
                          </span>
                        ))}
                      </div>
                    )}

                    {/* Network Info */}
                    {(item.network || item.collectionAddress) && (
                      <div className="space-y-1 pt-2 border-t border-white/5">
                        {item.network && (
                          <div className="flex items-center gap-2 font-mono text-xs text-white/50">
                            <Globe className="w-3 h-3" />
                            <span className="uppercase">{item.network}</span>
                          </div>
                        )}
                        {item.collectionAddress && (
                          <div className="flex items-center gap-2 font-mono text-xs text-white/50">
                            <Hash className="w-3 h-3" />
                            <span className="truncate" title={item.collectionAddress}>
                              {item.collectionAddress.slice(0, 8)}...{item.collectionAddress.slice(-6)}
                            </span>
                          </div>
                        )}
                      </div>
                    )}

                    {/* Actions */}
                    <div className="flex gap-2 pt-2">
                      {item.mintUrl && (
                        <a 
                          href={item.mintUrl}
                          target="_blank"
                          rel="noopener noreferrer"
                          className="flex-1 flex items-center justify-center gap-2 py-2 px-3 bg-white/10 rounded-lg font-mono text-xs uppercase tracking-wider text-white hover:bg-white/20 transition-colors"
                        >
                          Mint
                          <ExternalLink className="w-3 h-3" />
                        </a>
                      )}
                      <button
                        onClick={handleFullView}
                        className="flex-1 flex items-center justify-center gap-2 py-2 px-3 bg-white/10 rounded-lg font-mono text-xs uppercase tracking-wider text-white hover:bg-white/20 transition-colors"
                      >
                        Full View
                        <Maximize2 className="w-3 h-3" />
                      </button>
                    </div>
                  </div>
                </motion.div>
              )}
            </AnimatePresence>
          </div>

          {/* Visual Indicator for Auto-Hide */}
          {autoHide && (
            <motion.div
              className="absolute bottom-0 left-0 right-0 h-[2px] bg-white/20"
              initial={{ scaleX: 1 }}
              animate={{ scaleX: 0 }}
              transition={{ duration: 3, ease: 'linear' }}
            />
          )}
        </motion.div>
      )}
    </AnimatePresence>
  );
}
</file>

<file path="components/MobileHeader.tsx">
'use client';

interface MobileHeaderProps {
  onFilterClick: () => void;
  onSearchClick: () => void;
  activeFilterCount?: number;
  hasSearchQuery?: boolean;
}

export default function MobileHeader({ 
  onFilterClick, 
  onSearchClick, 
  activeFilterCount = 0,
  hasSearchQuery = false 
}: MobileHeaderProps) {
  return (
    <header className="fixed top-0 left-0 right-0 h-16 bg-black z-50 md:hidden">
      <div className="h-full px-4 flex items-center justify-between">
        {/* Filter Button */}
        <button
          onClick={onFilterClick}
          className={`px-4 py-2 rounded-full transition-colors ${
            activeFilterCount > 0 
              ? 'bg-white text-black' 
              : 'bg-white/10 hover:bg-white/20 text-white'
          }`}
          aria-label="Open filters"
        >
          <span className="font-mono text-xs uppercase tracking-[0.08em]">
            FILTER{activeFilterCount > 0 && ` (${activeFilterCount})`}
          </span>
        </button>

        {/* Search Button */}
        <button
          onClick={onSearchClick}
          className={`px-4 py-2 rounded-full transition-colors ${
            hasSearchQuery
              ? 'bg-white text-black'
              : 'bg-white/10 hover:bg-white/20 text-white'
          }`}
          aria-label="Open search"
        >
          <span className="font-mono text-xs uppercase tracking-[0.08em]">
            SEARCH
          </span>
        </button>
      </div>
    </header>
  );
}
</file>

<file path="components/MobileSearchModal.tsx">
'use client';

import { useRef, useEffect } from 'react';
import { X, Search, ArrowRight } from 'lucide-react';

interface MobileSearchModalProps {
  isOpen: boolean;
  searchQuery: string;
  submittedQuery: string;
  onSearchChange: (value: string) => void;
  onSearchSubmit: () => void;
  onClose: () => void;
}

export default function MobileSearchModal({ 
  isOpen,
  searchQuery,
  submittedQuery,
  onSearchChange,
  onSearchSubmit,
  onClose 
}: MobileSearchModalProps) {
  
  const inputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    if (isOpen && inputRef.current) {
      setTimeout(() => {
        inputRef.current?.focus();
      }, 100);
    }
  }, [isOpen]);

  if (!isOpen) return null;

  const handleClear = () => {
    onSearchChange('');
    inputRef.current?.focus();
  };

  const handleSubmit = () => {
    if (searchQuery) {
      onSearchSubmit();
      onClose();
    }
  };

  return (
    <div className="fixed inset-0 z-[60] bg-black/95 backdrop-blur-sm md:hidden">
      {/* Header */}
      <div className="flex items-center p-4">
        <div className="flex-1 relative">
          <div className="flex items-center bg-white/8 rounded-full overflow-hidden border border-white/10">
            <Search size={16} className="absolute left-4 text-white/60" />
            <input
              ref={inputRef}
              type="text"
              value={searchQuery}
              onChange={(e) => onSearchChange(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter' && searchQuery) {
                  e.preventDefault();
                  handleSubmit();
                }
              }}
              placeholder="SEARCH"
              className={`w-full bg-transparent text-white placeholder-white/40 font-mono text-xs uppercase tracking-[0.08em] py-3 pl-10 ${searchQuery ? 'pr-12' : 'pr-10'} outline-none focus-visible:ring-1 focus-visible:ring-white/20 focus-visible:ring-offset-1 focus-visible:ring-offset-black`}
            />
            {/* Smart button toggle: Arrow for submit, Clear for active search */}
            {searchQuery && (
              searchQuery !== submittedQuery ? (
                /* Submit button with arrow icon */
                <button
                  onClick={handleSubmit}
                  className="absolute right-3 transition-all duration-200 opacity-100 translate-x-0"
                  aria-label="Submit search"
                >
                  <ArrowRight size={14} className="text-white/60 hover:text-white transition-colors" />
                </button>
              ) : (
                /* Clear button */
                <button
                  onClick={handleClear}
                  className="absolute right-3 transition-all duration-200 opacity-100 translate-x-0"
                  aria-label="Clear search"
                >
                  <X size={14} className="text-white/60 hover:text-white transition-colors" />
                </button>
              )
            )}
          </div>
        </div>
        <button
          onClick={onClose}
          className="ml-4 text-white/60 hover:text-white transition-colors"
          aria-label="Close search"
        >
          <X size={24} />
        </button>
      </div>

      {/* Search hint */}
      <div className="px-4 mt-2">
        <p className="font-mono text-white/30 text-xs uppercase tracking-[0.08em]">
          {searchQuery.length === 0 && 'START TYPING TO SEARCH'}
          {searchQuery.length > 0 && searchQuery.length < 3 && `${searchQuery.length} CHARACTERS`}
          {searchQuery.length >= 3 && `SEARCHING FOR "${searchQuery.toUpperCase()}"`}
        </p>
      </div>
    </div>
  );
}
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  // Optimize images
  images: {
    formats: ['image/webp'],
    domains: ['lykbbceawbrmtursljvk.supabase.co'],
  },
  
  // Enable compression
  compress: true,
  
  // Optimize production build
  productionBrowserSourceMaps: false,
  
  // Enable strict mode for better performance
  reactStrictMode: true,
  
  // Configure headers for caching
  async headers() {
    return [
      {
        source: '/:path*.webp',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
      {
        source: '/data/:path*',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=86400, stale-while-revalidate=43200',
          },
        ],
      },
      {
        source: '/atlas-master.json',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable',
          },
        ],
      },
    ];
  },
};

export default nextConfig;
</file>

<file path="app/globals.css">
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: var(--font-geist-mono), monospace;
}
</file>

<file path="components/mobile/MinimalBottomSheet.tsx">
'use client';

import { useState, useRef, useEffect } from 'react';
import { Sheet } from 'react-modal-sheet';

interface MenuItem {
  id?: number;
  title: string;
  description: string;
  categories?: string[];
}

interface MinimalBottomSheetProps {
  item: MenuItem | null;
  isOpen: boolean;
  onClose?: () => void;
  isSphereInteracting?: boolean;
  onExpandedChange?: (expanded: boolean) => void;
}

export default function MinimalBottomSheet({ 
  item, 
  isOpen, 
  onClose,
  isSphereInteracting = false,
  onExpandedChange 
}: MinimalBottomSheetProps) {
  const [snapPoint, setSnapPoint] = useState(0);
  const contentRef = useRef<HTMLDivElement>(null);
  const [contentHeight, setContentHeight] = useState(300);

  // Minimal snap points
  const getSnapPoints = () => {
    const height = window.innerHeight;
    const minHeight = 72; // Just title height
    const maxHeight = Math.min(contentHeight + 100, height * 0.7);
    return [minHeight, maxHeight];
  };

  const [snapPoints, setSnapPoints] = useState(getSnapPoints);

  // Update content height
  useEffect(() => {
    if (contentRef.current) {
      setContentHeight(contentRef.current.scrollHeight);
    }
  }, [item]);

  // Update snap points
  useEffect(() => {
    setSnapPoints(getSnapPoints());
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [contentHeight]);

  // Auto-collapse on new item
  useEffect(() => {
    if (item) {
      setSnapPoint(0);
    }
  }, [item]);

  // Auto-collapse when sphere is interacting
  useEffect(() => {
    if (isSphereInteracting && snapPoint === 1) {
      setSnapPoint(0);
    }
  }, [isSphereInteracting, snapPoint]);

  // Report expansion state
  useEffect(() => {
    onExpandedChange?.(snapPoint === 1);
  }, [snapPoint, onExpandedChange]);

  if (!item) return null;

  const isExpanded = snapPoint === 1;

  return (
    <Sheet
      isOpen={isOpen}
      onClose={onClose || (() => {})}
      snapPoints={snapPoints}
      initialSnap={0}
      onSnap={setSnapPoint}
    >
      <Sheet.Container 
        style={{ 
          backgroundColor: 'rgba(0, 0, 0, 0.9)',
          backdropFilter: 'blur(12px)',
          borderTop: '1px solid rgba(255, 255, 255, 0.1)'
        }}
      >
        <Sheet.Header onTap={() => !isExpanded && setSnapPoint(1)} />
        
        {/* CRITICAL: No disableDrag, no onClick handlers that conflict with gestures */}
        <Sheet.Content>
          <div className="text-white font-mono">
            {/* Title - always visible, tap/click to expand */}
            <div 
              className="px-4 pb-3 pt-1"
              onClick={() => {
                // Tap/click to expand on both mobile and desktop
                if (!isExpanded) {
                  setSnapPoint(1);
                }
              }}
              style={{ cursor: !isExpanded ? 'pointer' : 'default' }}
            >
              <h3 className="text-xs uppercase tracking-wider text-white truncate">
                {item.title}
              </h3>
            </div>

            {/* Expanded content */}
            {isExpanded && (
              <div ref={contentRef} className="px-4 pb-4 space-y-3">
                {item.categories && item.categories[0] && (
                  <span className="text-[10px] uppercase text-white/50">
                    {item.categories[0]}
                  </span>
                )}
                
                <p className="text-xs text-white/70 leading-relaxed">
                  {item.description.length > 150 
                    ? item.description.substring(0, 150) + '...'
                    : item.description
                  }
                </p>
              </div>
            )}
          </div>
        </Sheet.Content>
      </Sheet.Container>
      
      {/* CRITICAL: Sheet.Backdrop must be present for proper touch handling */}
      <Sheet.Backdrop />
    </Sheet>
  );
}
</file>

<file path="components/BottomSheet.tsx">
'use client';

import { useState, useRef, useEffect, TouchEvent } from 'react';
import { ExternalLink, Maximize2 } from 'lucide-react';
import { formatMintDate, formatHash } from '@/lib/format';

interface BottomSheetProps {
  selectedItem: {
    id: string;
    title: string;
    description?: string;
    category?: string[];
    image_url?: string;
    mint_url?: string;
    collection_address?: string;
    network?: string;
    created_at?: string;
  } | null;
  onExpandImage?: () => void;
}

const COLLAPSED_HEIGHT = 80;
const HALF_HEIGHT_RATIO = 0.5;
const VELOCITY_THRESHOLD = 0.5;

export default function BottomSheet({ selectedItem, onExpandImage }: BottomSheetProps) {
  const [height, setHeight] = useState(COLLAPSED_HEIGHT);
  const [isDragging, setIsDragging] = useState(false);
  const sheetRef = useRef<HTMLDivElement>(null);
  const startY = useRef(0);
  const startHeight = useRef(0);
  const lastY = useRef(0);
  const lastTime = useRef(0);
  const velocity = useRef(0);

  useEffect(() => {
    // Reset height when item changes
    if (selectedItem) {
      setHeight(COLLAPSED_HEIGHT);
    }
  }, [selectedItem?.id]);

  const handleTouchStart = (e: TouchEvent) => {
    const touch = e.touches[0];
    startY.current = touch.clientY;
    startHeight.current = height;
    lastY.current = touch.clientY;
    lastTime.current = Date.now();
    velocity.current = 0;
    setIsDragging(true);
  };

  const handleTouchMove = (e: TouchEvent) => {
    if (!isDragging) return;
    
    const touch = e.touches[0];
    const deltaY = startY.current - touch.clientY;
    const newHeight = Math.max(
      COLLAPSED_HEIGHT,
      Math.min(window.innerHeight * 0.9, startHeight.current + deltaY)
    );
    
    // Calculate velocity
    const now = Date.now();
    const timeDelta = now - lastTime.current;
    if (timeDelta > 0) {
      velocity.current = (touch.clientY - lastY.current) / timeDelta;
    }
    
    lastY.current = touch.clientY;
    lastTime.current = now;
    
    setHeight(newHeight);
  };

  const handleTouchEnd = () => {
    if (!isDragging) return;
    setIsDragging(false);
    
    const windowHeight = window.innerHeight;
    const halfHeight = windowHeight * HALF_HEIGHT_RATIO;
    const fullHeight = windowHeight * 0.9;
    
    // Determine target height based on velocity and position
    let targetHeight = height;
    
    if (Math.abs(velocity.current) > VELOCITY_THRESHOLD) {
      // Fast swipe
      if (velocity.current > 0) {
        // Swiping down - collapse
        targetHeight = COLLAPSED_HEIGHT;
      } else {
        // Swiping up - expand
        targetHeight = fullHeight;
      }
    } else {
      // Slow drag - snap to nearest state
      const distances = [
        { height: COLLAPSED_HEIGHT, distance: Math.abs(height - COLLAPSED_HEIGHT) },
        { height: halfHeight, distance: Math.abs(height - halfHeight) },
        { height: fullHeight, distance: Math.abs(height - fullHeight) }
      ];
      
      distances.sort((a, b) => a.distance - b.distance);
      targetHeight = distances[0].height;
    }
    
    setHeight(targetHeight);
  };

  const handleTap = () => {
    if (height === COLLAPSED_HEIGHT) {
      setHeight(window.innerHeight * HALF_HEIGHT_RATIO);
    }
  };

  if (!selectedItem) return null;

  const date = formatMintDate(selectedItem.created_at);

  return (
    <div
      ref={sheetRef}
      className="fixed bottom-0 left-0 right-0 bg-black border-t border-white/10 z-50 md:hidden transition-none"
      style={{ 
        height: `${height}px`,
        transition: isDragging ? 'none' : 'height 0.3s cubic-bezier(0.4, 0, 0.2, 1)'
      }}
    >
      {/* Drag Handle */}
      <div 
        className="absolute top-0 left-0 right-0 h-6 flex justify-center items-center cursor-grab active:cursor-grabbing"
        onTouchStart={handleTouchStart}
        onTouchMove={handleTouchMove}
        onTouchEnd={handleTouchEnd}
        onClick={handleTap}
      >
        <div className="w-12 h-1 bg-white/30 rounded-full" />
      </div>

      {/* Content */}
      <div className="pt-8 px-4 pb-4 h-full overflow-y-auto">
        {/* Header - Always Visible */}
        <div className="mb-4">
          <h2 className="font-mono text-white uppercase text-sm tracking-[0.08em] mb-1">
            {selectedItem.title}
          </h2>
          <p className="font-mono text-white/60 text-xs uppercase tracking-[0.08em]">
            {date}
          </p>
        </div>

        {/* Expanded Content */}
        {height > COLLAPSED_HEIGHT * 1.5 && (
          <>
            {/* Category Tags */}
            {selectedItem.category && selectedItem.category.length > 0 && (
              <div className="flex flex-wrap gap-2 mb-4">
                {selectedItem.category.slice(0, 3).map((cat) => (
                  <span 
                    key={cat}
                    className="px-3 py-1 bg-white/10 rounded-full font-mono text-xs uppercase text-white/80 tracking-[0.08em]"
                  >
                    {cat}
                  </span>
                ))}
              </div>
            )}

            {/* Description */}
            {selectedItem.description && (
              <div className="mb-4">
                <p className="font-mono text-white/80 text-xs leading-relaxed">
                  {selectedItem.description}
                </p>
              </div>
            )}

            {/* Metadata */}
            <div className="space-y-3 pt-3 border-t border-white/10">
              {selectedItem.network && (
                <div className="font-mono text-white/60 text-xs uppercase">
                  {selectedItem.network}
                </div>
              )}
              
              {selectedItem.collection_address && (
                <div className="flex items-center gap-2">
                  <span className="font-mono text-white/60 text-xs">
                    # {formatHash(selectedItem.collection_address)}
                  </span>
                  <ExternalLink size={12} className="text-white/40" />
                </div>
              )}
            </div>

            {/* Actions */}
            <div className="flex gap-3 mt-6">
              {selectedItem.mint_url && (
                <a
                  href={selectedItem.mint_url}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="flex-1 py-3 px-4 bg-white text-black font-mono font-normal uppercase text-xs tracking-[0.08em] text-center"
                >
                  VIEW ORIGINAL
                </a>
              )}
              
              {onExpandImage && (
                <button
                  onClick={onExpandImage}
                  className="p-3 bg-white/10 hover:bg-white/20 transition-colors"
                  aria-label="Expand image"
                >
                  <Maximize2 size={16} className="text-white" />
                </button>
              )}
            </div>
          </>
        )}
      </div>
    </div>
  );
}
</file>

<file path="components/CategoryBar.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';

interface CategoryBarProps {
  categories: string[];
  activeCategories?: string[];
  activeCategory?: string | null; // backward compat
  onCategoryChange: (category: string | null) => void;
}

export default function CategoryBar({ categories, activeCategories = [], activeCategory = null, onCategoryChange }: CategoryBarProps) {
  const scrollRef = useRef<HTMLDivElement>(null);
  const [showLeftArrow, setShowLeftArrow] = useState(false);
  const [showRightArrow, setShowRightArrow] = useState(false);

  const checkScroll = () => {
    if (!scrollRef.current) return;
    const { scrollLeft, scrollWidth, clientWidth } = scrollRef.current;
    setShowLeftArrow(scrollLeft > 0);
    setShowRightArrow(scrollLeft < scrollWidth - clientWidth - 5);
  };

  useEffect(() => {
    checkScroll();
    const container = scrollRef.current;
    if (container) {
      container.addEventListener('scroll', checkScroll);
      window.addEventListener('resize', checkScroll);
      return () => {
        container.removeEventListener('scroll', checkScroll);
        window.removeEventListener('resize', checkScroll);
      };
    }
  }, []);

  const scroll = (direction: 'left' | 'right') => {
    if (!scrollRef.current) return;
    const scrollAmount = 200;
    scrollRef.current.scrollBy({
      left: direction === 'left' ? -scrollAmount : scrollAmount,
      behavior: 'smooth'
    });
  };

  return (
    <div className="relative w-full bg-black/80 backdrop-blur-sm border-b border-white/10 px-4 py-3">
      {/* Left Arrow */}
      {showLeftArrow && (
        <button
          onClick={() => scroll('left')}
          className="absolute left-0 top-1/2 -translate-y-1/2 z-10 bg-gradient-to-r from-black to-transparent pl-2 pr-4 h-full flex items-center"
          aria-label="Scroll left"
        >
          <svg className="w-5 h-5 text-white/60 hover:text-white transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
          </svg>
        </button>
      )}

      {/* Categories Container */}
      <div
        ref={scrollRef}
        className="flex gap-2 overflow-x-auto scrollbar-hide scroll-smooth"
        style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
      >
        {/* All Category */}
        <button
          onClick={() => onCategoryChange(null)}
          className={`
            px-4 py-2 rounded-full text-sm font-medium transition-all duration-200 whitespace-nowrap uppercase font-mono
            ${(activeCategory === null && activeCategories.length === 0)
              ? 'bg-white text-black'
              : 'bg-white/10 text-white/70 hover:bg-white/20 hover:text-white'
            }
          `}
        >
          All
        </button>

        {/* Category Pills */}
        {categories.map((category) => (
          <button
            key={category}
            onClick={() => onCategoryChange(category)}
            className={`
              px-4 py-2 rounded-full text-sm font-medium transition-all duration-200 whitespace-nowrap uppercase font-mono
              ${(activeCategory === category) || activeCategories.includes(category)
                ? 'bg-white text-black'
                : 'bg-white/10 text-white/70 hover:bg-white/20 hover:text-white'
              }
            `}
          >
            {category}
          </button>
        ))}
      </div>

      {/* Right Arrow */}
      {showRightArrow && (
        <button
          onClick={() => scroll('right')}
          className="absolute right-0 top-1/2 -translate-y-1/2 z-10 bg-gradient-to-l from-black to-transparent pr-2 pl-4 h-full flex items-center"
          aria-label="Scroll right"
        >
          <svg className="w-5 h-5 text-white/60 hover:text-white transition-colors" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
        </button>
      )}
    </div>
  );
}
</file>

<file path="components/DynamicSpherePositions.ts">
import { vec3 } from "gl-matrix";

export class DynamicSpherePositions {
  private readonly BASE_RADIUS = 2.0;
  private readonly ITEM_SCALE = 0.25;
  private readonly GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5)); // Golden angle in radians
  
  /**
   * Calculate optimal sphere radius based on item count to prevent overlap
   */
  calculateOptimalRadius(itemCount: number): number {
    // Proportional scaling: if 42 items need radius 2.0, then N items need proportionally more
    // This maintains the same angular spacing as the original design
    const scaleFactor = Math.sqrt(itemCount / 42);
    return this.BASE_RADIUS * scaleFactor;
  }
  
  /**
   * Generate exactly N positions well-distributed on a sphere
   */
  generatePositions(itemCount: number, radius: number): vec3[] {
    if (itemCount === 0) return [];
    if (itemCount === 1) {
      // Single item at front of sphere
      return [vec3.fromValues(0, 0, radius)];
    }
    
    // For different item counts, use different strategies
    if (itemCount <= 12) {
      return this.getIcosahedronPositions(itemCount, radius);
    } else if (itemCount <= 42) {
      return this.getSubdividedIcosahedronPositions(itemCount, radius);
    } else {
      return this.getFibonacciSpherePositions(itemCount, radius);
    }
  }
  
  /**
   * Get positions based on icosahedron vertices (up to 12 items)
   */
  private getIcosahedronPositions(count: number, radius: number): vec3[] {
    const t = (1 + Math.sqrt(5)) / 2; // Golden ratio
    const vertices: vec3[] = [
      // 12 vertices of icosahedron
      vec3.fromValues(-1, t, 0),
      vec3.fromValues(1, t, 0),
      vec3.fromValues(-1, -t, 0),
      vec3.fromValues(1, -t, 0),
      vec3.fromValues(0, -1, t),
      vec3.fromValues(0, 1, t),
      vec3.fromValues(0, -1, -t),
      vec3.fromValues(0, 1, -t),
      vec3.fromValues(t, 0, -1),
      vec3.fromValues(t, 0, 1),
      vec3.fromValues(-t, 0, -1),
      vec3.fromValues(-t, 0, 1),
    ];
    
    // Normalize and scale vertices
    const positions: vec3[] = [];
    for (let i = 0; i < Math.min(count, vertices.length); i++) {
      const pos = vec3.create();
      vec3.normalize(pos, vertices[i]);
      vec3.scale(pos, pos, radius);
      positions.push(pos);
    }
    
    return positions;
  }
  
  /**
   * Get positions for subdivided icosahedron pattern (13-42 items)
   */
  private getSubdividedIcosahedronPositions(count: number, radius: number): vec3[] {
    // Use a uniform distribution that mimics subdivided icosahedron
    const positions: vec3[] = [];
    
    // Generate points using a spiral method that gives icosahedron-like distribution
    for (let i = 0; i < count; i++) {
      const t = i / (count - 1);
      const inclination = Math.acos(1 - 2 * t);
      const azimuth = 2 * Math.PI * i / 1.618033988749895; // Golden ratio
      
      const x = Math.sin(inclination) * Math.cos(azimuth) * radius;
      const y = Math.cos(inclination) * radius;
      const z = Math.sin(inclination) * Math.sin(azimuth) * radius;
      
      positions.push(vec3.fromValues(x, y, z));
    }
    
    return positions;
  }
  
  /**
   * Generate positions using Fibonacci sphere algorithm for optimal distribution
   */
  private getFibonacciSpherePositions(count: number, radius: number): vec3[] {
    const positions: vec3[] = [];
    
    for (let i = 0; i < count; i++) {
      // Generate evenly distributed points on sphere using Fibonacci spiral
      const y = 1 - (i / (count - 1)) * 2; // y goes from 1 to -1
      const radiusAtY = Math.sqrt(1 - y * y); // radius of circle at y
      const theta = this.GOLDEN_ANGLE * i; // golden angle increment
      
      const x = Math.cos(theta) * radiusAtY;
      const z = Math.sin(theta) * radiusAtY;
      
      // Scale by sphere radius
      positions.push(vec3.fromValues(x * radius, y * radius, z * radius));
    }
    
    return positions;
  }
  
  /**
   * Check if current positions need update based on new item count
   */
  needsUpdate(currentCount: number, newCount: number): boolean {
    return currentCount !== newCount;
  }
}
</file>

<file path="components/MetadataPanel.tsx">
'use client';

import { ExternalLink } from 'lucide-react';
import { formatMintDate, formatHash, getBlockExplorerUrl } from '@/lib/format';

interface MetadataPanelProps {
  selectedItem: {
    id: string;
    title: string;
    description?: string;
    category?: string[];
    primary_category?: string;
    mint_url?: string;
    collection_address?: string;
    token_id?: string;
    network?: string;
    created_at?: string;
  } | null;
}

export default function MetadataPanel({ selectedItem }: MetadataPanelProps) {
  if (!selectedItem) {
    return (
      <aside className="fixed right-0 top-16 bottom-0 w-80 bg-black border-l border-white/10 z-40">
        <div className="p-6 text-white/40 font-mono text-xs uppercase tracking-[0.08em]">
          Select an item to view details
        </div>
      </aside>
    );
  }

  const date = formatMintDate(selectedItem.created_at);

  return (
    <aside className="fixed right-0 top-16 bottom-0 w-80 bg-black border-l border-white/10 z-40 overflow-y-auto">
      <div className="p-6 space-y-6">
        {/* Title and Date */}
        <div>
          <h2 className="font-mono text-white uppercase text-sm tracking-[0.08em] mb-1">
            {selectedItem.title || 'ITEM TITLE'}
          </h2>
          <p className="font-mono text-white/60 text-xs uppercase tracking-[0.08em]">
            {date}
          </p>
        </div>

        {/* Category Tags */}
        {selectedItem.category && selectedItem.category.length > 0 && (
          <div className="flex flex-wrap gap-2">
            {selectedItem.category.slice(0, 3).map((cat) => (
              <span 
                key={cat}
                className="px-3 py-1 bg-white/10 rounded-full font-mono text-xs uppercase text-white/80 tracking-[0.08em]"
              >
                {cat}
              </span>
            ))}
          </div>
        )}

        {/* Description */}
        {selectedItem.description && (
          <div>
            <p className="font-mono text-white/80 text-xs leading-relaxed">
              {selectedItem.description}
            </p>
          </div>
        )}

        {/* Network and Hash */}
        <div className="space-y-3 pt-3 border-t border-white/10">
          {/* Network */}
          {selectedItem.network && (
            <div className="flex items-center gap-2">
              <span className="font-mono text-white/60 text-xs uppercase">
                {selectedItem.network}
              </span>
            </div>
          )}

          {/* Collection Hash */}
          {selectedItem.collection_address && (
            <a
              href={getBlockExplorerUrl(selectedItem.collection_address, selectedItem.network)}
              target="_blank"
              rel="noopener noreferrer"
              className="flex items-center gap-2 group"
            >
              <span className="font-mono text-white/60 text-xs">
                #
              </span>
              <span className="font-mono font-normal uppercase text-white/60 group-hover:text-white text-xs transition-colors">
                {formatHash(selectedItem.collection_address)}
              </span>
              <ExternalLink size={12} className="text-white/40 group-hover:text-white/60 transition-colors" />
            </a>
          )}
        </div>

        {/* View Original Button */}
        {selectedItem.mint_url && (
          <div className="pt-4">
            <a
              href={selectedItem.mint_url}
              target="_blank"
              rel="noopener noreferrer"
              className="block w-full py-3 px-4 bg-white text-black font-mono font-normal uppercase text-xs tracking-[0.08em] text-center hover:bg-white/90 transition-colors"
            >
              VIEW ORIGINAL
            </a>
          </div>
        )}
      </div>
    </aside>
  );
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Infinite Menu - NFT Explorer",
  description: "Interactive 3D spherical menu for exploring NFT collections",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <head>
        {/* DNS prefetch for faster connections */}
        <link rel="dns-prefetch" href="https://lykbbceawbrmtursljvk.supabase.co" />
        <link rel="preconnect" href="https://lykbbceawbrmtursljvk.supabase.co" crossOrigin="anonymous" />
        
        {/* Preload critical resources for instant loading */}
        <link rel="preload" href="/atlas-master-0.webp" as="image" type="image/webp" />
        <link rel="preload" href="/atlas-master-1.webp" as="image" type="image/webp" />
        <link rel="preload" href="/atlas-master-2.webp" as="image" type="image/webp" />
        <link rel="preload" href="/atlas-master.json" as="fetch" crossOrigin="anonymous" />
        <link rel="preload" href="/data/items.json" as="fetch" crossOrigin="anonymous" />
      </head>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
</file>

<file path="components/TopNav.tsx">
'use client';

import { useState, useRef } from 'react';
import { Search, X, ArrowRight } from 'lucide-react';

interface TopNavProps {
  searchQuery: string;
  onSearchChange: (value: string) => void;
}

export default function TopNav({ searchQuery, onSearchChange }: TopNavProps) {
  const [isFocused, setIsFocused] = useState(false);
  const [submittedQuery, setSubmittedQuery] = useState('');
  const searchInputRef = useRef<HTMLInputElement>(null);

  const handleClearSearch = () => {
    onSearchChange('');
    setSubmittedQuery('');
    searchInputRef.current?.focus();
  };

  const handleSubmitSearch = () => {
    if (searchQuery) {
      setSubmittedQuery(searchQuery);
      searchInputRef.current?.blur();
    }
  };

  const handleSearchFocus = () => {
    setIsFocused(true);
  };

  const handleSearchBlur = () => {
    setIsFocused(false);
  };

  return (
    <nav className="fixed top-0 left-0 right-0 h-16 bg-black border-b border-white/10 z-50">
      <div className="h-full px-6 grid grid-cols-3 items-center">
        {/* Logo/Title - Left Column */}
        <div className="flex items-center">
          <h1 className="font-mono text-white uppercase text-sm tracking-[0.08em]">
            DESIGN EVERYDAYS
          </h1>
        </div>

        {/* Center Search - Middle Column */}
        <div className="flex justify-center">
          <div className="relative w-full max-w-md">
            <div 
              className={`
                relative flex items-center rounded-full overflow-hidden
                transition-all duration-200
                ${isFocused || searchQuery 
                  ? 'bg-white/8 border border-white/10' 
                  : 'bg-white/5 border border-transparent'
                }
              `}
            >
              <Search 
                size={16} 
                className={`
                  absolute left-4 transition-colors duration-200
                  ${isFocused || searchQuery ? 'text-white' : 'text-white/40'}
                `}
              />
              
              <input
                ref={searchInputRef}
                type="text"
                value={searchQuery}
                onChange={(e) => onSearchChange(e.target.value)}
                onFocus={handleSearchFocus}
                onBlur={handleSearchBlur}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' && searchQuery) {
                    e.preventDefault();
                    handleSubmitSearch();
                  }
                }}
                placeholder="SEARCH"
                className={`
                  w-full bg-transparent text-white placeholder-white/40
                  font-mono text-xs uppercase tracking-[0.08em]
                  pl-10 ${searchQuery ? 'pr-12' : 'pr-10'} py-3 outline-none
                  transition-all duration-200
                  focus-visible:ring-1 focus-visible:ring-white/20 focus-visible:ring-offset-1 focus-visible:ring-offset-black
                `}
              />

              {/* Smart button toggle: Arrow for submit, Clear for active search */}
              {searchQuery && (
                searchQuery !== submittedQuery ? (
                  /* Submit button with arrow icon */
                  <button
                    onClick={handleSubmitSearch}
                    className="absolute right-3 transition-all duration-200 opacity-100 translate-x-0"
                    aria-label="Submit search"
                  >
                    <ArrowRight 
                      size={14} 
                      className="text-white/60 hover:text-white transition-colors"
                    />
                  </button>
                ) : (
                  /* Clear button */
                  <button
                    onClick={handleClearSearch}
                    className="absolute right-3 transition-all duration-200 opacity-100 translate-x-0"
                    aria-label="Clear search"
                  >
                    <X 
                      size={14} 
                      className="text-white/60 hover:text-white transition-colors"
                    />
                  </button>
                )
              )}
            </div>

          </div>
        </div>

        {/* About Link - Right Column */}
        <div className="flex items-center justify-end">
          <button 
            className="font-mono font-normal uppercase text-sm tracking-normal text-white/60 hover:text-white/80 transition-colors"
            onClick={() => console.log('About page - coming soon')}
          >
            ABOUT
          </button>
        </div>
      </div>
    </nav>
  );
}
</file>

<file path="package.json">
{
  "name": "infinite-menu-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "export:csv": "tsx scripts/exportCategories.ts"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.50.2",
    "@types/gl-matrix": "^2.4.5",
    "file-type": "^18.7.0",
    "framer-motion": "^12.23.12",
    "gl-matrix": "^3.4.3",
    "lucide-react": "^0.539.0",
    "next": "15.3.4",
    "phosphor-react": "^1.4.1",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-modal-sheet": "^4.4.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/node-fetch": "^2.6.12",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@types/sharp": "^0.31.1",
    "@types/three": "^0.177.0",
    "dotenv": "^16.6.1",
    "eslint": "^9",
    "eslint-config-next": "15.3.4",
    "node-fetch": "^3.3.2",
    "sharp": "^0.34.3",
    "tailwindcss": "^4",
    "ts-node": "^10.9.2",
    "tsx": "^4.20.3",
    "typescript": "^5"
  }
}
</file>

<file path="CLAUDE.md">
# CLAUDE.md

Guidance for Claude Code (claude.ai/code) when working with this repository.

##  TL;DR - Quick Context

**What:** Interactive 3D gallery for NFT "everydays" collection (750+ items)  
**Stack:** Next.js 15.3.4 + TypeScript + Supabase + WebGL + Tailwind CSS v4  
**Core Feature:** 3D spherical menu that dynamically scales based on item count  
**User Context:** Non-technical product designer - explain concepts clearly  

###  CRITICAL - DO NOT:
- Modify the original Supabase database (project: `vqpdoiontwjazcxbmrhq`)
- Create files unless absolutely necessary (prefer editing existing)
- Add comments to code unless explicitly requested
- Use emojis in code or files unless user asks
- Commit changes unless explicitly requested

###  ALWAYS:
- Use Supabase MCP for database operations (project: `lykbbceawbrmtursljvk`)
- Run lint/typecheck after code changes: `npm run lint` and `npx tsc --noEmit`
- Follow UPPERCASE pattern for all clickable text elements
- Test with `npm run dev` at http://localhost:3000
- Address root causes, not symptoms

##  Quick Start

```bash
# 1. Install dependencies
npm install

# 2. Set up environment (REQUIRED)
cp .env.example .env.local
# Add your Supabase credentials:
# NEXT_PUBLIC_SUPABASE_URL=your_url
# NEXT_PUBLIC_SUPABASE_ANON_KEY=your_key

# 3. Run development server
npm run dev

# 4. Open http://localhost:3000
```

### Essential Commands
```bash
npm run dev          # Development server
npm run build        # Production build
npm run lint         # Run ESLint
npx tsc --noEmit    # Type checking
```

##  Project Structure

```
/
 app/              # Next.js app router pages
 components/       # React components
    InfiniteMenu.tsx    # Core 3D WebGL sphere (2000+ lines)
    MetadataPanel.tsx   # Desktop item details panel
    BottomSheet.tsx     # Mobile draggable metadata
    ...                 # UI components
 lib/              # Core utilities
    supabase.ts   # Database client & data fetching
 scripts/          # Utility scripts
    categorization/     # NFT categorization scripts
    mint-dates/         # Mint date fetching scripts
    migrations/         # Database migrations
 data/             # Data exports and results
 docs/             # Documentation
     architecture/       # Technical design docs
     plans/             # Implementation plans
     research/          # Research notes
```

##  Architecture Overview

1. **Data Layer** (`lib/supabase.ts`)
   - Connects to Supabase using environment variables (REQUIRED: see Environment Setup)
   - Fetches from `nft_tokens_filtered` view (optimized subset of data)
   - Supports category filtering and search via RPC functions
   - Maps NFTToken interface to MenuItem format for the 3D menu

2. **3D Visualization** (`components/InfiniteMenu.tsx`)
   - WebGL2-based spherical menu with ~2000 lines of custom implementation
   - Dynamic sphere scaling based on item count (sqrt(itemCount/42) * 2.0)
   - Pre-allocated matrices for animation loop (performance critical)
   - Texture atlas system for loading 750+ images efficiently
   - Camera positioning: maintains 1.0 unit distance from sphere surface

3. **UI Layer** (`app/page.tsx`)
   - Three-column layout: categories sidebar (160px) | 3D sphere | details panel (320px)
   - Debounced search (300ms) to prevent excessive API calls
   - Category multi-select with immediate filtering
   - Typography-first design with uppercase clickable elements

##  Database

**Production DB:** Supabase project `lykbbceawbrmtursljvk`  
**Main View:** `nft_tokens_filtered` (optimized subset)

### Key Fields
- **Identity:** `id`, `token_id`, `title`, `description`
- **Media:** `image_url`, `thumbnail_url` (Supabase Storage)
- **Categories:** `category[]`, `primary_category`, `subcat`
- **Blockchain:** `mint_url`, `network`, `collection_address`, `created_at`

### Collections
- **Ethereum:** `0x5908eb01497b5d8e53c339ea0186050d487c8d0c` (346 tokens)
- **Zora:** `0x5abf0c04ab7196e2bdd19313b479baebd9f7791b` (374 tokens)
- **Start Date:** March 23, 2023 (Token #1 - Media Provenance)

##  Performance Notes

- **Texture Atlases:** 256 images per atlas (only first atlas currently used)
- **Dynamic Scaling:** Sphere radius = `2.0 * sqrt(itemCount / 42)`
- **Camera Distance:** Always 1.0 unit from sphere surface when focused
- **Memory:** Pre-allocated matrices in render loop
- **Search:** 300ms debounce on input


##  Key Features

### Desktop (768px+)
- Three-column layout: Filters (160px) | 3D Sphere | Metadata (320px)
- Expandable search bar in top navigation
- Minimal text-only category filters with active indicators
- Full metadata panel with mint details

### Mobile (<768px)
- Full-screen 3D sphere
- Draggable bottom sheet (80px collapsed  50%  90% expanded)
- Touch gestures with velocity-based animations
- Modal overlays for filter and search

##  Design System

### Typography Rules
- **ALL CAPS** for all clickable text (buttons, links)
- **Monospace font** throughout
- **Letter spacing:** `tracking-[0.08em]` for active states

### Colors
- Background: Pure black `#000`
- Active: 100% white
- Inactive: 60% white
- Hover: 80% white

### Categories (in order)
ALL, PAYMENTS, TRADING, AGENTS, SOCIAL, IDENTITY, MESSAGING, GATING, PRIVACY, REWARDS, ART, INVEST, WALLET

##  Common Tasks

### Update NFT Metadata
1. Use Supabase MCP to query `nft_tokens` table
2. Update using `execute_sql` or `apply_migration`
3. Verify changes appear in `nft_tokens_filtered` view

### Modify Categories
1. Check current categories in `lib/supabase.ts`
2. Update `CATEGORIES` array if adding new ones
3. Run scripts in `scripts/categorization/` for bulk updates

### Debug Sphere Rendering
1. Check browser console for WebGL errors
2. Verify texture atlases are loading (Network tab)
3. Look for "Switching from fallback to atlas textures" log
4. Items 256+ will show repeated images (known limitation)

### Test Mobile Layout
1. Use browser DevTools responsive mode
2. Test bottom sheet drag gestures
3. Verify modals open/close properly
4. Check touch event handling



##  Known Issues & Limitations

1. **Texture Atlas:** Only first 256 items display correctly (items 256+ show repeated images)
2. **WebGL Init:** May show colored squares briefly on first load (React StrictMode issue)
3. **Mobile Performance:** Large item counts (500+) may lag on older devices
4. **Search:** Exact match only, no fuzzy search

##  Additional Documentation

- `/docs/DESIGN_PATTERNS.md` - Design system details
- `/docs/architecture/DESIGN_SYSTEM.md` - Complete design specifications
- `/docs/architecture/infinite_menu_component.md` - WebGL implementation details
- `/docs/plans/dynamic-sphere-plan.md` - Sphere scaling solution
- `/docs/research/` - Various improvement proposals

##  Recent Changes (September 2025)

- Fixed mint dates display (now shows actual dates from March 23, 2023)
- Reorganized repository structure (scripts/, docs/, data/ folders)
- Cleaned up root directory
- Updated CLAUDE.md for better onboarding

---

*Last updated: September 4, 2025*
</file>

<file path="lib/supabase.ts">
import { createClient } from '@supabase/supabase-js'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables. Please set NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY in your .env.local file')
}

export const supabase = createClient(supabaseUrl, supabaseAnonKey)

// Type definitions based on the nft_tokens table schema
export interface NFTToken {
  id: number
  token_id: string
  title: string | null
  description: string | null
  image_url: string | null
  original_url: string | null
  mint_url: string | null
  network: string | null
  collection_address: string | null
  mime_type: string | null
  downloadable_uri: string | null
  raw_metadata: Record<string, unknown> | null
  created_at: string | null
  updated_at: string | null
  embedding: number[] | null
  thumbnail_url: string | null
  category: string[] | null
  primary_category?: string | null
  subcat?: string | null
}

// Helper function to fetch NFT tokens
export async function fetchNFTTokens(limit?: number) {
  let query = supabase
    .from('nft_tokens_filtered')
    .select('*')
    .order('created_at', { ascending: false })
  
  if (limit) {
    query = query.limit(limit)
  }
  
  const { data, error } = await query
  
  if (error) {
    console.error('Error fetching NFT tokens:', error)
    throw error
  }
  
  return data as NFTToken[]
}

// Helper function to fetch a single NFT token by ID
export async function fetchNFTTokenById(id: number) {
  const { data, error } = await supabase
    .from('nft_tokens_filtered')
    .select('*')
    .eq('id', id)
    .single()
  
  if (error) {
    console.error('Error fetching NFT token:', error)
    throw error
  }
  
  return data as NFTToken
}

// Map NFT tokens to InfiniteMenu format
export function mapNFTToMenuItem(token: NFTToken) {
  // Use the same image URL for both atlas and hi-res to prevent visual pops
  const imageUrl = token.image_url || token.thumbnail_url || 'https://picsum.photos/300/300?grayscale';
  return {
    id: token.id,
    image: imageUrl, // Same URL for consistency
    imageHighRes: imageUrl, // Same URL to prevent swapping
    link: `/token/${token.id}`,
    title: token.title || token.token_id || `Token #${token.id}`,
    description: token.description || 'No description available',
    mintUrl: token.mint_url || null,
    createdAt: token.created_at || null,
    categories: token.category || [],
    network: token.network || null,
    collectionAddress: token.collection_address || null,
  };
}

// Fetch infinite menu data with optional category and search filters
export async function fetchInfiniteMenuData(categories?: string[] | null, searchQuery?: string, subcat?: string | null) {
  try {
    const cats = categories && categories.length > 0 ? categories : null;
    const q = (searchQuery ?? '').trim();

    // For default view (no search query), use direct query to get all items
    // This preserves the original behavior of showing all filtered items
    if (!q) {
      let query = supabase
        .from('nft_tokens_filtered')
        .select('*')
        .order('id', { ascending: true });

      // Apply subcategory filter if provided
      if (subcat) {
        query = query.eq('subcat', subcat);
      }

      // Apply category filter if provided
      if (cats) {
        query = query.overlaps('category', cats);
      }

      const { data, error } = await query;
      if (error) {
        console.error('Error fetching NFT tokens:', error);
        return [];
      }
      return (data ?? []).map(mapNFTToMenuItem);
    }

    // For searches, use enhanced RPC with synonym expansion and fuzzy matching
    // Try enhanced search first
    const { data: enhancedData, error: enhancedError } = await supabase
      .rpc('rpc_search_nfts_enhanced', { q, cats });

    if (!enhancedError && enhancedData) {
      return (enhancedData ?? []).map(mapNFTToMenuItem);
    }

    // Fall back to regular RPC search if enhanced is not available
    if (enhancedError) {
      console.log('Enhanced search not available, falling back to regular search');
    }

    const { data, error } = await supabase
      .rpc('rpc_search_nfts', { q, cats });

    if (error) {
      console.error('Error fetching NFT tokens via rpc_search_nfts:', error);
      // Graceful fallback to simple filter if RPC fails
      let query = supabase
        .from('nft_tokens_filtered')
        .select('*')
        .order('id', { ascending: true });
      if (cats) query = query.overlaps('category', cats);
      if (q) query = query.or(`title.ilike.%${q}%,description.ilike.%${q}%`);
      const fallback = await query;
      if (fallback.error) {
        console.error('Fallback query failed:', fallback.error);
        return [];
      }
      return (fallback.data ?? []).map(mapNFTToMenuItem);
    }

    return (data ?? []).map(mapNFTToMenuItem);
  } catch (e) {
    console.error('Unexpected error fetching NFT tokens:', e);
    return [];
  }
}

// Define the new 15-category system order
const CATEGORY_ORDER = [
  'defi',
  'payments', 
  'trading',
  'agents',
  'gaming',
  'creators',
  'social',
  'identity',
  'messaging',
  'gating',
  'privacy',
  'rewards',
  'data',
  'infrastructure',
  'tools'
];

// Fetch all available categories
export async function fetchCategories(): Promise<string[]> {
  const { data, error } = await supabase
    .from('nft_tokens_filtered')
    .select('category')
    .not('category', 'is', null);

  if (error) {
    console.error('Error fetching categories:', error);
    return [];
  }

  // Extract unique categories from the array fields
  const categoriesSet = new Set<string>();
  data.forEach(row => {
    if (row.category && Array.isArray(row.category)) {
      row.category.forEach((cat: string) => categoriesSet.add(cat));
    }
  });

  // Sort categories by the defined order, with any unknown categories at the end
  const categories = Array.from(categoriesSet);
  return categories.sort((a, b) => {
    const aIndex = CATEGORY_ORDER.indexOf(a);
    const bIndex = CATEGORY_ORDER.indexOf(b);
    
    // If both are in the order, sort by order
    if (aIndex !== -1 && bIndex !== -1) {
      return aIndex - bIndex;
    }
    // If only a is in the order, it comes first
    if (aIndex !== -1) return -1;
    // If only b is in the order, it comes first
    if (bIndex !== -1) return 1;
    // Neither in order, sort alphabetically
    return a.localeCompare(b);
  });
} 

// Fetch available subcategories, optionally scoped to a primary category
export async function fetchSubcategories(primaryCategory?: string | null): Promise<string[]> {
  let query = supabase
    .from('nft_tokens_filtered')
    .select('subcat, primary_category')
    .not('subcat', 'is', null);

  if (primaryCategory) {
    query = query.eq('primary_category', primaryCategory);
  }

  const { data, error } = await query;
  if (error) {
    console.error('Error fetching subcategories:', error);
    return [];
  }

  const set = new Set<string>();
  data.forEach(row => {
    if (row.subcat) set.add(row.subcat);
  });
  return Array.from(set).sort();
}
</file>

<file path="app/page.tsx">
import { promises as fs } from 'fs';
import path from 'path';
import type { StaticNFTData } from '@/lib/staticTypes';
import GalleryClient from './gallery-client';

// Enable ISR with 24-hour revalidation
export const revalidate = 86400; // 24 hours in seconds

async function getStaticData(): Promise<StaticNFTData> {
  // In production, this runs at build time and is cached
  // In development, it runs on each request
  const dataPath = path.join(process.cwd(), 'public', 'data', 'items.json');
  const jsonData = await fs.readFile(dataPath, 'utf-8');
  return JSON.parse(jsonData);
}

export default async function Home() {
  const staticData = await getStaticData();
  
  return <GalleryClient initialData={staticData} />;
}
</file>

<file path="components/InfiniteMenu.tsx">
import { useRef, useState, useEffect } from "react";
import { mat4, quat, vec2, vec3 } from "gl-matrix";
import { DynamicSpherePositions } from "./DynamicSpherePositions";

const discVertShaderSource = `#version 300 es

uniform mat4 uWorldMatrix;
uniform mat4 uViewMatrix;
uniform mat4 uProjectionMatrix;
uniform vec3 uCameraPosition;
uniform vec4 uRotationAxisVelocity;

in vec3 aModelPosition;
in vec3 aModelNormal;
in vec2 aModelUvs;
in mat4 aInstanceMatrix;

out vec2 vUvs;
out float vAlpha;
flat out int vInstanceId;

#define PI 3.141593

void main() {
  vec4 worldPosition = uWorldMatrix * aInstanceMatrix * vec4(aModelPosition, 1.);

  vec3 centerPos = (uWorldMatrix * aInstanceMatrix * vec4(0., 0., 0., 1.)).xyz;
  float radius = length(centerPos.xyz);

  if (gl_VertexID > 0) {
    vec3 rotationAxis = uRotationAxisVelocity.xyz;
    float rotationVelocity = min(.15, uRotationAxisVelocity.w * 15.);
    vec3 stretchDir = normalize(cross(centerPos, rotationAxis));
    vec3 relativeVertexPos = normalize(worldPosition.xyz - centerPos);
    float strength = dot(stretchDir, relativeVertexPos);
    float invAbsStrength = min(0., abs(strength) - 1.);
    strength = rotationVelocity * sign(strength) * abs(invAbsStrength * invAbsStrength * invAbsStrength + 1.);
    worldPosition.xyz += stretchDir * strength;
  }

  worldPosition.xyz = radius * normalize(worldPosition.xyz);

  gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;

  vAlpha = smoothstep(0.5, 1., normalize(worldPosition.xyz).z) * .9 + .1;
  vUvs = aModelUvs;
  vInstanceId = gl_InstanceID;
}
`;

const discFragShaderSource = `#version 300 es
precision highp float;

uniform sampler2D uTex;
uniform sampler2D uTex1; // Second atlas
uniform sampler2D uTex2; // Third atlas
uniform sampler2D uHighTex;
uniform int uItemCount;
uniform int uAtlasSize;
uniform float uHighId;
uniform sampler2D uAtlasPositionMap; // Texture containing position mappings
uniform int uMaxItems; // Number of items in mapping

out vec4 outColor;

in vec2 vUvs;
in float vAlpha;
flat in int vInstanceId;

void main() {
  int itemIndex = vInstanceId % uItemCount;
  
  // Look up the actual atlas position from the mapping texture
  int atlasPosition = itemIndex; // Default fallback
  
  if (itemIndex < uMaxItems) {
    // Read the mapping from the texture (stored in R channel)
    vec4 mappingValue = texelFetch(uAtlasPositionMap, ivec2(itemIndex, 0), 0);
    float mappedPos = mappingValue.r * 1024.0;
    if (mappedPos >= 0.0) {
      atlasPosition = int(mappedPos);
    }
  }
  
  int itemsPerAtlas = uAtlasSize * uAtlasSize; // Compute based on actual atlas size
  int atlasIndex = atlasPosition / itemsPerAtlas; // Which atlas (0, 1, 2)
  int atlasItemIndex = atlasPosition % itemsPerAtlas; // Position within that atlas
  
  int cellsPerRow = uAtlasSize;
  int cellX = atlasItemIndex % cellsPerRow;
  int cellY = atlasItemIndex / cellsPerRow;
  vec2 cellSize = vec2(1.0) / vec2(float(cellsPerRow));
  vec2 cellOffset = vec2(float(cellX), float(cellY)) * cellSize;

  ivec2 texSize = textureSize(uTex, 0);
  float imageAspect = float(texSize.x) / float(texSize.y);
  float containerAspect = 1.0;

  float scale = max(imageAspect / containerAspect, 
                   containerAspect / imageAspect);

  vec2 st = vec2(vUvs.x, 1.0 - vUvs.y);
  st = (st - 0.5) * scale + 0.5;

  st = clamp(st, 0.0, 1.0);
  st = st * cellSize + cellOffset;

  // Select the correct atlas based on atlasIndex
  vec4 atlasColor;
  if (atlasIndex == 0) {
    atlasColor = texture(uTex, st);
  } else if (atlasIndex == 1) {
    atlasColor = texture(uTex1, st);
  } else if (atlasIndex == 2) {
    atlasColor = texture(uTex2, st);
  } else {
    // Fallback to first atlas
    atlasColor = texture(uTex, st);
  }
  
  // High-res texture overlay - only apply to the focused item
  float itemIndexFloat = float(itemIndex);
  float useHighRes = step(0.5, 1.0 - abs(itemIndexFloat - uHighId)) * step(0.0, uHighId);
  
  vec2 hiResSt = vec2(vUvs.x, 1.0 - vUvs.y);
  vec4 hiResColor = texture(uHighTex, hiResSt);
  
  // Mix atlas and hi-res based on whether this is the focused item
  outColor = mix(atlasColor, hiResColor, useHighRes);
  outColor.a *= vAlpha;
}
`;

class Face {
  public a: number;
  public b: number;
  public c: number;

  constructor(a: number, b: number, c: number) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
}

class Vertex {
  public position: vec3;
  public normal: vec3;
  public uv: vec2;

  constructor(x: number, y: number, z: number) {
    this.position = vec3.fromValues(x, y, z);
    this.normal = vec3.create();
    this.uv = vec2.create();
  }
}

class Geometry {
  public vertices: Vertex[];
  public faces: Face[];

  constructor() {
    this.vertices = [];
    this.faces = [];
  }

  public addVertex(...args: number[]): this {
    for (let i = 0; i < args.length; i += 3) {
      this.vertices.push(new Vertex(args[i], args[i + 1], args[i + 2]));
    }
    return this;
  }

  public addFace(...args: number[]): this {
    for (let i = 0; i < args.length; i += 3) {
      this.faces.push(new Face(args[i], args[i + 1], args[i + 2]));
    }
    return this;
  }

  public get lastVertex(): Vertex {
    return this.vertices[this.vertices.length - 1];
  }

  public subdivide(divisions = 1): this {
    const midPointCache: Record<string, number> = {};
    let f = this.faces;

    for (let div = 0; div < divisions; ++div) {
      const newFaces = new Array<Face>(f.length * 4);

      f.forEach((face, ndx) => {
        const mAB = this.getMidPoint(face.a, face.b, midPointCache);
        const mBC = this.getMidPoint(face.b, face.c, midPointCache);
        const mCA = this.getMidPoint(face.c, face.a, midPointCache);

        const i = ndx * 4;
        newFaces[i + 0] = new Face(face.a, mAB, mCA);
        newFaces[i + 1] = new Face(face.b, mBC, mAB);
        newFaces[i + 2] = new Face(face.c, mCA, mBC);
        newFaces[i + 3] = new Face(mAB, mBC, mCA);
      });

      f = newFaces;
    }

    this.faces = f;
    return this;
  }

  public spherize(radius = 1): this {
    this.vertices.forEach((vertex) => {
      vec3.normalize(vertex.normal, vertex.position);
      vec3.scale(vertex.position, vertex.normal, radius);
    });
    return this;
  }

  public get data(): {
    vertices: Float32Array;
    indices: Uint16Array;
    normals: Float32Array;
    uvs: Float32Array;
  } {
    return {
      vertices: this.vertexData,
      indices: this.indexData,
      normals: this.normalData,
      uvs: this.uvData,
    };
  }

  public get vertexData(): Float32Array {
    return new Float32Array(
      this.vertices.flatMap((v) => Array.from(v.position))
    );
  }

  public get normalData(): Float32Array {
    return new Float32Array(this.vertices.flatMap((v) => Array.from(v.normal)));
  }

  public get uvData(): Float32Array {
    return new Float32Array(this.vertices.flatMap((v) => Array.from(v.uv)));
  }

  public get indexData(): Uint16Array {
    return new Uint16Array(this.faces.flatMap((f) => [f.a, f.b, f.c]));
  }

  public getMidPoint(
    ndxA: number,
    ndxB: number,
    cache: Record<string, number>
  ): number {
    const cacheKey = ndxA < ndxB ? `k_${ndxB}_${ndxA}` : `k_${ndxA}_${ndxB}`;
    if (Object.prototype.hasOwnProperty.call(cache, cacheKey)) {
      return cache[cacheKey];
    }
    const a = this.vertices[ndxA].position;
    const b = this.vertices[ndxB].position;
    const ndx = this.vertices.length;
    cache[cacheKey] = ndx;
    this.addVertex(
      (a[0] + b[0]) * 0.5,
      (a[1] + b[1]) * 0.5,
      (a[2] + b[2]) * 0.5
    );
    return ndx;
  }
}

class IcosahedronGeometry extends Geometry {
  constructor() {
    super();
    const t = Math.sqrt(5) * 0.5 + 0.5;
    this.addVertex(
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      0,
      0,
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      t,
      0,
      -1,
      t,
      0,
      1,
      -t,
      0,
      -1,
      -t,
      0,
      1
    ).addFace(
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    );
  }
}

class DiscGeometry extends Geometry {
  constructor(steps = 4, radius = 1) {
    super();
    const safeSteps = Math.max(4, steps);
    const alpha = (2 * Math.PI) / safeSteps;

    this.addVertex(0, 0, 0);
    this.lastVertex.uv[0] = 0.5;
    this.lastVertex.uv[1] = 0.5;

    for (let i = 0; i < safeSteps; ++i) {
      const x = Math.cos(alpha * i);
      const y = Math.sin(alpha * i);
      this.addVertex(radius * x, radius * y, 0);
      this.lastVertex.uv[0] = x * 0.5 + 0.5;
      this.lastVertex.uv[1] = y * 0.5 + 0.5;

      if (i > 0) {
        this.addFace(0, i, i + 1);
      }
    }
    this.addFace(0, safeSteps, 1);
  }
}

class RoundedSquareGeometry extends Geometry {
  constructor(size = 1, cornerRadius = 0.2, cornerSteps = 8) {
    super();
    
    // Center vertex
    this.addVertex(0, 0, 0);
    this.lastVertex.uv[0] = 0.5;
    this.lastVertex.uv[1] = 0.5;
    
    const halfSize = size * 0.5;
    const radius = Math.min(cornerRadius, halfSize);
    const innerSize = halfSize - radius;
    
    let vertexIndex = 1;
    
    // Generate vertices for rounded corners and edges
    const corners = [
      { x: innerSize, y: innerSize, startAngle: 0 },        // Top-right
      { x: -innerSize, y: innerSize, startAngle: Math.PI / 2 },   // Top-left
      { x: -innerSize, y: -innerSize, startAngle: Math.PI },      // Bottom-left
      { x: innerSize, y: -innerSize, startAngle: Math.PI * 1.5 }  // Bottom-right
    ];
    
    for (let c = 0; c < corners.length; c++) {
      const corner = corners[c];
      const angleStep = (Math.PI / 2) / cornerSteps;
      
      // Generate vertices for this corner
      for (let i = 0; i <= cornerSteps; i++) {
        const angle = corner.startAngle + angleStep * i;
        const x = corner.x + Math.cos(angle) * radius;
        const y = corner.y + Math.sin(angle) * radius;
        
        this.addVertex(x, y, 0);
        const uv = this.lastVertex.uv;
        uv[0] = (x / size) + 0.5;
        uv[1] = (y / size) + 0.5;
        
        // Create triangles connecting to center
        if (c > 0 || i > 0) {
          const prevIndex = vertexIndex - 1;
          const currIndex = vertexIndex;
          
          // Skip the connection between last vertex of one corner and first of next
          if (i > 0 || (c > 0 && i === 0)) {
            this.addFace(0, prevIndex, currIndex);
          }
        }
        
        vertexIndex++;
      }
    }
    
    // Connect last vertex to first vertex
    this.addFace(0, vertexIndex - 1, 1);
  }
}

function createShader(
  gl: WebGL2RenderingContext,
  type: number,
  source: string
): WebGLShader | null {
  const shader = gl.createShader(type);
  if (!shader) return null;
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

  if (success) {
    return shader;
  }

  const error = gl.getShaderInfoLog(shader);
  console.error('Shader compilation failed:', error);
  console.error('Shader type:', type === gl.VERTEX_SHADER ? 'VERTEX' : 'FRAGMENT');
  console.error('Shader source:', source);
  gl.deleteShader(shader);
  return null;
}

function createProgram(
  gl: WebGL2RenderingContext,
  shaderSources: [string, string],
  transformFeedbackVaryings?: string[] | null,
  attribLocations?: Record<string, number>
): WebGLProgram | null {
  const program = gl.createProgram();
  if (!program) return null;

  [gl.VERTEX_SHADER, gl.FRAGMENT_SHADER].forEach((type, ndx) => {
    const shader = createShader(gl, type, shaderSources[ndx]);
    if (shader) {
      gl.attachShader(program, shader);
    }
  });

  if (transformFeedbackVaryings) {
    gl.transformFeedbackVaryings(
      program,
      transformFeedbackVaryings,
      gl.SEPARATE_ATTRIBS
    );
  }

  if (attribLocations) {
    for (const attrib in attribLocations) {
      if (Object.prototype.hasOwnProperty.call(attribLocations, attrib)) {
        gl.bindAttribLocation(program, attribLocations[attrib], attrib);
      }
    }
  }

  gl.linkProgram(program);
  const success = gl.getProgramParameter(program, gl.LINK_STATUS);

  if (success) {
    return program;
  }

  const error = gl.getProgramInfoLog(program);
  console.error('Program linking failed:', error);
  gl.deleteProgram(program);
  return null;
}

function makeVertexArray(
  gl: WebGL2RenderingContext,
  bufLocNumElmPairs: Array<[WebGLBuffer, number, number]>,
  indices?: Uint16Array
): WebGLVertexArrayObject | null {
  const va = gl.createVertexArray();
  if (!va) return null;

  gl.bindVertexArray(va);

  for (const [buffer, loc, numElem] of bufLocNumElmPairs) {
    if (loc === -1) continue;
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.enableVertexAttribArray(loc);
    gl.vertexAttribPointer(loc, numElem, gl.FLOAT, false, 0, 0);
  }

  if (indices) {
    const indexBuffer = gl.createBuffer();
    if (indexBuffer) {
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    }
  }

  gl.bindVertexArray(null);
  return va;
}

function resizeCanvasToDisplaySize(canvas: HTMLCanvasElement): boolean {
  const dpr = Math.min(2, window.devicePixelRatio || 1);
  const displayWidth = Math.round(canvas.clientWidth * dpr);
  const displayHeight = Math.round(canvas.clientHeight * dpr);
  const needResize =
    canvas.width !== displayWidth || canvas.height !== displayHeight;
  if (needResize) {
    canvas.width = displayWidth;
    canvas.height = displayHeight;
  }
  return needResize;
}

function makeBuffer(
  gl: WebGL2RenderingContext,
  sizeOrData: number | ArrayBufferView,
  usage: number
): WebGLBuffer {
  const buf = gl.createBuffer();
  if (!buf) {
    throw new Error("Failed to create WebGL buffer.");
  }
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);

  if (typeof sizeOrData === "number") {
    gl.bufferData(gl.ARRAY_BUFFER, sizeOrData, usage);
  } else {
    gl.bufferData(gl.ARRAY_BUFFER, sizeOrData, usage);
  }

  gl.bindBuffer(gl.ARRAY_BUFFER, null);
  return buf;
}

function createAndSetupTexture(
  gl: WebGL2RenderingContext,
  minFilter: number,
  magFilter: number,
  wrapS: number,
  wrapT: number
): WebGLTexture {
  const texture = gl.createTexture();
  if (!texture) {
    throw new Error("Failed to create WebGL texture.");
  }
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);
  return texture;
}

type UpdateCallback = (deltaTime: number) => void;

class ArcballControl {
  private canvas: HTMLCanvasElement;
  private updateCallback: UpdateCallback;

  public isPointerDown = false;
  public orientation = quat.create();
  public pointerRotation = quat.create();
  public rotationVelocity = 0;
  public rotationAxis = vec3.fromValues(1, 0, 0);

  public snapDirection = vec3.fromValues(0, 0, -1);
  public snapTargetDirection: vec3 | null = null;

  private pointerPos = vec2.create();
  private previousPointerPos = vec2.create();
  private _rotationVelocity = 0;
  private _combinedQuat = quat.create();

  private readonly EPSILON = 0.1;
  private readonly IDENTITY_QUAT = quat.create();

  constructor(canvas: HTMLCanvasElement, updateCallback?: UpdateCallback) {
    this.canvas = canvas;
    this.updateCallback = updateCallback || (() => undefined);

    canvas.addEventListener("pointerdown", (e: PointerEvent) => {
      vec2.set(this.pointerPos, e.clientX, e.clientY);
      vec2.copy(this.previousPointerPos, this.pointerPos);
      this.isPointerDown = true;
    });
    canvas.addEventListener("pointerup", () => {
      this.isPointerDown = false;
    });
    canvas.addEventListener("pointerleave", () => {
      this.isPointerDown = false;
    });
    canvas.addEventListener("pointermove", (e: PointerEvent) => {
      if (this.isPointerDown) {
        vec2.set(this.pointerPos, e.clientX, e.clientY);
      }
    });
    canvas.style.touchAction = "none";
  }

  public update(deltaTime: number, targetFrameDuration = 16): void {
    const timeScale = deltaTime / targetFrameDuration + 0.00001;
    let angleFactor = timeScale;
    const snapRotation = quat.create();

    if (this.isPointerDown) {
      const INTENSITY = 0.3 * timeScale;
      const ANGLE_AMPLIFICATION = 5 / timeScale;
      const midPointerPos = vec2.sub(
        vec2.create(),
        this.pointerPos,
        this.previousPointerPos
      );
      vec2.scale(midPointerPos, midPointerPos, INTENSITY);

      if (vec2.sqrLen(midPointerPos) > this.EPSILON) {
        vec2.add(midPointerPos, this.previousPointerPos, midPointerPos);

        const p = this.project(midPointerPos);
        const q = this.project(this.previousPointerPos);
        const a = vec3.normalize(vec3.create(), p);
        const b = vec3.normalize(vec3.create(), q);

        vec2.copy(this.previousPointerPos, midPointerPos);

        angleFactor *= ANGLE_AMPLIFICATION;

        this.quatFromVectors(a, b, this.pointerRotation, angleFactor);
      } else {
        quat.slerp(
          this.pointerRotation,
          this.pointerRotation,
          this.IDENTITY_QUAT,
          INTENSITY
        );
      }
    } else {
      const INTENSITY = 0.1 * timeScale;
      quat.slerp(
        this.pointerRotation,
        this.pointerRotation,
        this.IDENTITY_QUAT,
        INTENSITY
      );

      if (this.snapTargetDirection) {
        const SNAPPING_INTENSITY = 0.2;
        const a = this.snapTargetDirection;
        const b = this.snapDirection;
        const sqrDist = vec3.squaredDistance(a, b);
        const distanceFactor = Math.max(0.1, 1 - sqrDist * 10);
        angleFactor *= SNAPPING_INTENSITY * distanceFactor;
        this.quatFromVectors(a, b, snapRotation, angleFactor);
      }
    }

    const combinedQuat = quat.multiply(
      quat.create(),
      snapRotation,
      this.pointerRotation
    );
    this.orientation = quat.multiply(
      quat.create(),
      combinedQuat,
      this.orientation
    );
    quat.normalize(this.orientation, this.orientation);

    const RA_INTENSITY = 0.8 * timeScale;
    quat.slerp(
      this._combinedQuat,
      this._combinedQuat,
      combinedQuat,
      RA_INTENSITY
    );
    quat.normalize(this._combinedQuat, this._combinedQuat);

    const rad = Math.acos(this._combinedQuat[3]) * 2.0;
    const s = Math.sin(rad / 2.0);
    let rv = 0;
    if (s > 0.000001) {
      rv = rad / (2 * Math.PI);
      this.rotationAxis[0] = this._combinedQuat[0] / s;
      this.rotationAxis[1] = this._combinedQuat[1] / s;
      this.rotationAxis[2] = this._combinedQuat[2] / s;
    }

    const RV_INTENSITY = 0.5 * timeScale;
    this._rotationVelocity += (rv - this._rotationVelocity) * RV_INTENSITY;
    this.rotationVelocity = this._rotationVelocity / timeScale;

    this.updateCallback(deltaTime);
  }

  private quatFromVectors(
    a: vec3,
    b: vec3,
    out: quat,
    angleFactor = 1
  ): { q: quat; axis: vec3; angle: number } {
    const axis = vec3.cross(vec3.create(), a, b);
    vec3.normalize(axis, axis);
    const d = Math.max(-1, Math.min(1, vec3.dot(a, b)));
    const angle = Math.acos(d) * angleFactor;
    quat.setAxisAngle(out, axis, angle);
    return { q: out, axis, angle };
  }

  private project(pos: vec2): vec3 {
    const r = 2;
    const w = this.canvas.clientWidth;
    const h = this.canvas.clientHeight;
    const s = Math.max(w, h) - 1;

    const x = (2 * pos[0] - w - 1) / s;
    const y = (2 * pos[1] - h - 1) / s;
    let z = 0;
    const xySq = x * x + y * y;
    const rSq = r * r;

    if (xySq <= rSq / 2.0) {
      z = Math.sqrt(rSq - xySq);
    } else {
      z = rSq / Math.sqrt(xySq);
    }
    return vec3.fromValues(-x, y, z);
  }
}

interface MenuItem {
  id?: number;
  image: string;
  imageHighRes?: string;
  link: string;
  title: string;
  description: string;
  mintUrl?: string | null;
  createdAt?: string | null;
  categories?: string[];
  network?: string | null;
  collectionAddress?: string | null;
}

type ActiveItemCallback = (index: number) => void;
type MovementChangeCallback = (isMoving: boolean) => void;
type InitCallback = (instance: InfiniteGridMenu) => void;

interface Camera {
  matrix: mat4;
  near: number;
  far: number;
  fov: number;
  aspect: number;
  position: vec3;
  up: vec3;
  matrices: {
    view: mat4;
    projection: mat4;
    inversProjection: mat4;
  };
}

interface AtlasMapping {
  id: string;
  atlas: number;
  x: number;
  y: number;
  width: number;
  height: number;
}

class InfiniteGridMenu {
  private gl: WebGL2RenderingContext | null = null;
  private discProgram: WebGLProgram | null = null;
  private discVAO: WebGLVertexArrayObject | null = null;
  private discBuffers!: {
    vertices: Float32Array;
    indices: Uint16Array;
    normals: Float32Array;
    uvs: Float32Array;
  };
  private icoGeo!: IcosahedronGeometry;
  private discGeo!: DiscGeometry;
  private dynamicPositions: DynamicSpherePositions;
  private worldMatrix = mat4.create();
  private tex: WebGLTexture | null = null;
  private atlases: WebGLTexture[] = [];
  private atlasMapping: AtlasMapping[] = [];
  private atlasMappingMap: Map<string, AtlasMapping> = new Map(); // O(1) lookup
  private atlasPositionMapTexture: WebGLTexture | null = null; // Texture containing position mappings
  private usingFallbackTexture: boolean = false;
  private atlasesLoaded: boolean = false;
  private control!: ArcballControl;
  private animationFrameId: number | null = null;
  private currentFocusedIndex: number = -1;
  
  // High-res texture management
  private hiResTexture: WebGLTexture | null = null;
  private hiResIndex: number = -1;
  private hiResLoading: boolean = false;
  private hiResLoadTimer: number | null = null;
  private lastFocusChangeTime: number = 0;
  
  // Atlas creation cancellation
  private atlasAbortController: AbortController | null = null;

  private discLocations!: {
    aModelPosition: number;
    aModelUvs: number;
    aInstanceMatrix: number;
    uWorldMatrix: WebGLUniformLocation | null;
    uViewMatrix: WebGLUniformLocation | null;
    uProjectionMatrix: WebGLUniformLocation | null;
    uCameraPosition: WebGLUniformLocation | null;
    uScaleFactor: WebGLUniformLocation | null;
    uRotationAxisVelocity: WebGLUniformLocation | null;
    uTex: WebGLUniformLocation | null;
    uTex1: WebGLUniformLocation | null;
    uTex2: WebGLUniformLocation | null;
    uFrames: WebGLUniformLocation | null;
    uItemCount: WebGLUniformLocation | null;
    uAtlasSize: WebGLUniformLocation | null;
    uHighTex: WebGLUniformLocation | null;
    uHighId: WebGLUniformLocation | null;
    uAtlasPositionMap: WebGLUniformLocation | null;
    uMaxItems: WebGLUniformLocation | null;
  };

  private viewportSize = vec2.create();
  private drawBufferSize = vec2.create();

  private discInstances!: {
    matricesArray: Float32Array;
    matrices: Float32Array[];
    buffer: WebGLBuffer | null;
  };

  private instancePositions: vec3[] = [];
  private DISC_INSTANCE_COUNT = 0;
  private atlasSize = 1;

  private _time = 0;
  private _deltaTime = 0;
  private _deltaFrames = 0;
  private _frames = 0;

  private movementActive = false;

  private TARGET_FRAME_DURATION = 1000 / 60;
  private SPHERE_RADIUS = 2;
  
  // Constants for maintaining consistent item visual size
  private readonly ITEM_SCALE = 0.25; // Fixed scale for all items
  private readonly ITEM_DIAMETER = 0.5; // 2 * ITEM_SCALE
  
  // Original setup reference (42 items, radius 2.0, camera at 3.0)
  // Calculate the visual angle: how big the item appears in the original setup
  // tan(angle/2) = (item_radius) / (camera_distance_from_item)
  // tan(angle/2) = 0.25 / 1.0 = 0.25
  // angle = 2 * atan(0.25)  28.07 degrees
  private readonly ORIGINAL_VISUAL_ANGLE = 2 * Math.atan(0.25); // ~0.49 radians

  public camera: Camera = {
    matrix: mat4.create(),
    near: 0.1,
    far: 40,
    fov: Math.PI / 4,
    aspect: 1,
    position: vec3.fromValues(0, 0, 3), // Will be updated based on sphere radius
    up: vec3.fromValues(0, 1, 0),
    matrices: {
      view: mat4.create(),
      projection: mat4.create(),
      inversProjection: mat4.create(),
    },
  };

  public smoothRotationVelocity = 0;
  public scaleFactor = 1.0;

  // Pre-allocated resources for animation loop (performance optimization)
  private animationTempPositions: vec3[] = [];
  private animationTempMatrices: mat4[] = [];
  private animationTempVec3: vec3 = vec3.create();
  private animationTempMatrix1: mat4 = mat4.create();
  private animationTempMatrix2: mat4 = mat4.create();
  private animationTempMatrix3: mat4 = mat4.create();
  private animationTempMatrix4: mat4 = mat4.create();
  private animationTempMatrix5: mat4 = mat4.create();

  constructor(
    private canvas: HTMLCanvasElement,
    private items: MenuItem[],
    private onActiveItemChange: ActiveItemCallback,
    private onMovementChange: MovementChangeCallback,
    onInit?: InitCallback,
    private initialFocusId?: number,
    private onAtlasLoaded?: () => void
  ) {
    this.dynamicPositions = new DynamicSpherePositions();
    this.init(onInit);
  }

  public resize(): void {
    const needsResize = resizeCanvasToDisplaySize(this.canvas);
    if (!this.gl) return;
    if (needsResize) {
      this.gl.viewport(
        0,
        0,
        this.gl.drawingBufferWidth,
        this.gl.drawingBufferHeight
      );
    }
    this.updateProjectionMatrix();
  }

  public run(time = 0): void {
    this._deltaTime = Math.min(32, time - this._time);
    this._time = time;
    this._deltaFrames = this._deltaTime / this.TARGET_FRAME_DURATION;
    this._frames += this._deltaFrames;

    this.animate(this._deltaTime);
    this.render();

    this.animationFrameId = requestAnimationFrame((t) => this.run(t));
  }

  private init(onInit?: InitCallback): void {
    const gl = this.canvas.getContext("webgl2", {
      antialias: true,
      alpha: false,
    });
    if (!gl) {
      throw new Error("No WebGL 2 context!");
    }
    this.gl = gl;
    
    // Test basic shader compilation
    const testVert = `#version 300 es
    in vec3 position;
    void main() {
      gl_Position = vec4(position, 1.0);
    }`;
    const testFrag = `#version 300 es
    precision highp float;
    out vec4 color;
    void main() {
      color = vec4(1.0, 0.0, 0.0, 1.0);
    }`;
    
    const testVertShader = gl.createShader(gl.VERTEX_SHADER);
    if (testVertShader) {
      gl.shaderSource(testVertShader, testVert);
      gl.compileShader(testVertShader);
      const success = gl.getShaderParameter(testVertShader, gl.COMPILE_STATUS);
      if (!success) {
        console.error("Test vertex shader failed:", gl.getShaderInfoLog(testVertShader));
      } else {
        // Test vertex shader compiled successfully
      }
      gl.deleteShader(testVertShader);
    }
    
    const testFragShader = gl.createShader(gl.FRAGMENT_SHADER);
    if (testFragShader) {
      gl.shaderSource(testFragShader, testFrag);
      gl.compileShader(testFragShader);
      const success = gl.getShaderParameter(testFragShader, gl.COMPILE_STATUS);
      if (!success) {
        console.error("Test fragment shader failed:", gl.getShaderInfoLog(testFragShader));
      } else {
        // Test fragment shader compiled successfully
      }
      gl.deleteShader(testFragShader);
    }

    vec2.set(
      this.viewportSize,
      this.canvas.clientWidth,
      this.canvas.clientHeight
    );
    vec2.clone(this.drawBufferSize);

    this.discProgram = createProgram(
      gl,
      [discVertShaderSource, discFragShaderSource],
      null,
      {
        aModelPosition: 0,
        aModelNormal: 1,
        aModelUvs: 2,
        aInstanceMatrix: 3,
      }
    );
    
    if (!this.discProgram) {
      throw new Error("Failed to create shader program - check console for shader compilation errors");
    }

    this.discLocations = {
      aModelPosition: gl.getAttribLocation(this.discProgram!, "aModelPosition"),
      aModelUvs: gl.getAttribLocation(this.discProgram!, "aModelUvs"),
      aInstanceMatrix: gl.getAttribLocation(
        this.discProgram!,
        "aInstanceMatrix"
      ),
      uWorldMatrix: gl.getUniformLocation(this.discProgram!, "uWorldMatrix"),
      uViewMatrix: gl.getUniformLocation(this.discProgram!, "uViewMatrix"),
      uProjectionMatrix: gl.getUniformLocation(
        this.discProgram!,
        "uProjectionMatrix"
      ),
      uCameraPosition: gl.getUniformLocation(
        this.discProgram!,
        "uCameraPosition"
      ),
      uScaleFactor: gl.getUniformLocation(this.discProgram!, "uScaleFactor"),
      uRotationAxisVelocity: gl.getUniformLocation(
        this.discProgram!,
        "uRotationAxisVelocity"
      ),
      uTex: gl.getUniformLocation(this.discProgram!, "uTex"),
      uTex1: gl.getUniformLocation(this.discProgram!, "uTex1"),
      uTex2: gl.getUniformLocation(this.discProgram!, "uTex2"),
      uFrames: gl.getUniformLocation(this.discProgram!, "uFrames"),
      uItemCount: gl.getUniformLocation(this.discProgram!, "uItemCount"),
      uAtlasSize: gl.getUniformLocation(this.discProgram!, "uAtlasSize"),
      uHighTex: gl.getUniformLocation(this.discProgram!, "uHighTex"),
      uHighId: gl.getUniformLocation(this.discProgram!, "uHighId"),
      uAtlasPositionMap: gl.getUniformLocation(this.discProgram!, "uAtlasPositionMap"),
      uMaxItems: gl.getUniformLocation(this.discProgram!, "uMaxItems"),
    };

    this.discGeo = new RoundedSquareGeometry(1, 0.15, 8);
    this.discBuffers = this.discGeo.data;
    this.discVAO = makeVertexArray(
      gl,
      [
        [
          makeBuffer(gl, this.discBuffers.vertices, gl.STATIC_DRAW),
          this.discLocations.aModelPosition,
          3,
        ],
        [
          makeBuffer(gl, this.discBuffers.uvs, gl.STATIC_DRAW),
          this.discLocations.aModelUvs,
          2,
        ],
      ],
      this.discBuffers.indices
    );

    // Use dynamic positions based on item count
    const itemCount = this.items.length || 1;
    this.SPHERE_RADIUS = this.dynamicPositions.calculateOptimalRadius(itemCount);
    this.instancePositions = this.dynamicPositions.generatePositions(itemCount, this.SPHERE_RADIUS);
    this.DISC_INSTANCE_COUNT = this.instancePositions.length;
    
    // Pre-allocate arrays for animation loop to avoid GC pressure
    this.animationTempPositions = new Array(this.DISC_INSTANCE_COUNT);
    this.animationTempMatrices = new Array(this.DISC_INSTANCE_COUNT);
    for (let i = 0; i < this.DISC_INSTANCE_COUNT; i++) {
      this.animationTempPositions[i] = vec3.create();
      this.animationTempMatrices[i] = mat4.create();
    }
    
    // Keep legacy geometry for compatibility
    this.icoGeo = new IcosahedronGeometry();
    this.icoGeo.subdivide(1).spherize(this.SPHERE_RADIUS);
    this.initDiscInstances(this.DISC_INSTANCE_COUNT);
    
    // Initialize static master atlas
    // Use setTimeout to ensure WebGL context is fully ready
    setTimeout(() => {
      if (this.gl) {
        this.initTexture(); // Load static master atlas
      } else {
        console.error('WebGL context not available after timeout');
        this.initTextureFallback();
      }
    }, 0);
    
    this.control = new ArcballControl(this.canvas, (deltaTime) =>
      this.onControlUpdate(deltaTime)
    );

    // Set initial focus if specified
    if (this.initialFocusId !== undefined) {
      this.setInitialFocus(this.initialFocusId);
    } else {
      // No specific focus, load high-res for whatever is at front (index 0)
      // This ensures the first visible item is sharp immediately
      if (this.items.length > 0) {
        const nearestIndex = this.findNearestVertexIndex();
        const itemIndex = nearestIndex % this.items.length;
        this.currentFocusedIndex = itemIndex;
        this.loadHighResTexture(itemIndex);
      }
    }

    // Set initial camera position at constant distance from sphere surface
    // Original: sphere radius 2.0, camera at 3.0 (1.0 unit from surface)
    vec3.set(this.camera.position, 0, 0, this.SPHERE_RADIUS + 1.0);
    
    this.updateCameraMatrix();
    this.updateProjectionMatrix();

    this.resize();
    if (onInit) {
      onInit(this);
    }
  }

  private async initTexture(): Promise<void> {
    if (!this.gl) {
      return;
    }
    
    // Load static master atlas instead of generating dynamically
    await this.loadStaticMasterAtlas();
  }
  
  private async loadStaticMasterAtlas(): Promise<void> {
    if (!this.gl) return;
    
    try {
      // Detect mobile and use appropriate atlas
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || window.innerWidth < 768;
      const atlasPrefix = isMobile ? 'atlas-master-mobile' : 'atlas-master';
      
      // Load the mapping
      const mappingResponse = await fetch(`/${atlasPrefix}.json`);
      if (!mappingResponse.ok) {
        throw new Error(`Failed to load atlas mapping: ${mappingResponse.status}`);
      }
      this.atlasMapping = await mappingResponse.json();
      
      // Build Map for O(1) lookups
      this.atlasMappingMap.clear();
      this.atlasMapping.forEach(entry => {
        this.atlasMappingMap.set(entry.id, entry);
      });
      
      // Determine how many atlases exist (based on new tile sizes)
      const itemsPerAtlas = 256;  // 16x16 = 256 for both desktop and mobile
      const atlasCount = Math.ceil(this.atlasMapping.length / itemsPerAtlas);
      
      // Load all atlas textures
      const atlasPromises: Promise<void>[] = [];
      for (let i = 0; i < Math.min(atlasCount, 3); i++) { // Max 3 atlases supported by shader
        atlasPromises.push(this.loadStaticAtlas(`${atlasPrefix}-${i}.webp`, i));
      }
      
      await Promise.all(atlasPromises);
      
      // Use the first atlas as primary
      if (this.atlases.length > 0) {
        this.tex = this.atlases[0];
        this.usingFallbackTexture = false;
      }
      
      // Set atlas size (tiles per row: 256px tiles on 4096px atlas = 16 for both desktop and mobile)
      this.atlasSize = 16; // Always 16x16 = 256 tiles per atlas
      
      // Build position mapping for current items
      this.buildAtlasPositionMap();
      
      // Mark atlases as loaded and notify
      this.atlasesLoaded = true;
      if (this.onAtlasLoaded) {
        this.onAtlasLoaded();
      }
      
    } catch (error) {
      console.error('Failed to load static master atlas:', error);
      this.initTextureFallback();
      // Still mark as loaded even with fallback
      this.atlasesLoaded = true;
      if (this.onAtlasLoaded) {
        this.onAtlasLoaded();
      }
    }
  }
  
  private loadStaticAtlas(url: string, index: number): Promise<void> {
    return new Promise((resolve, reject) => {
      if (!this.gl) {
        reject(new Error('No WebGL context'));
        return;
      }
      
      const gl = this.gl;
      const texture = createAndSetupTexture(
        gl,
        gl.LINEAR,
        gl.LINEAR,
        gl.CLAMP_TO_EDGE,
        gl.CLAMP_TO_EDGE
      );
      
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          img
        );
        gl.generateMipmap(gl.TEXTURE_2D);
        
        this.atlases[index] = texture;
        resolve();
      };
      img.onerror = (e) => {
        console.error(`Failed to load atlas from ${url}:`, e);
        reject(new Error(`Failed to load atlas from ${url}`));
      };
      img.src = '/' + url;
    });
  }
  
  
  private initTextureFallback(): void {
    if (!this.gl) return;
    const gl = this.gl;
    
    // console.log('Initializing fallback texture...');
    this.usingFallbackTexture = true;
    
    // Simple fallback - create colored squares
    const itemCount = Math.max(1, this.items.length);
    // For fallback, use 16x16 grid matching our new atlas layout
    // This means we can show first 256 items in fallback
    this.atlasSize = 16;
    const maxItems = Math.min(itemCount, 256);
    const cellSize = 256;
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d")!;
    canvas.width = this.atlasSize * cellSize;
    canvas.height = this.atlasSize * cellSize;
    
    // Only render up to maxItems in the fallback
    for (let i = 0; i < maxItems; i++) {
      const x = (i % this.atlasSize) * cellSize;
      const y = Math.floor(i / this.atlasSize) * cellSize;
      ctx.fillStyle = `hsl(${(i * 360) / maxItems}, 70%, 50%)`;
      ctx.fillRect(x, y, cellSize, cellSize);
    }

    // Create texture first!
    this.tex = createAndSetupTexture(
      gl,
      gl.LINEAR,
      gl.LINEAR,
      gl.CLAMP_TO_EDGE,
      gl.CLAMP_TO_EDGE
    );

    gl.bindTexture(gl.TEXTURE_2D, this.tex);
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.RGBA,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      canvas
    );
    gl.generateMipmap(gl.TEXTURE_2D);
    // console.log(`Fallback texture atlas created: ${this.atlasSize}x${this.atlasSize} grid, showing ${maxItems} of ${itemCount} items`);
  }
  
  // Build per-filter dynamic atlases in array order so atlasPosition == itemIndex
  
  private buildAtlasPositionMap(): void {
    if (!this.gl) return;
    const gl = this.gl;
    
    // console.log('Building atlas position map texture...');
    
    // Create a texture to store the mapping
    const maxItems = Math.min(this.items.length, 1024);
    const mappingData = new Float32Array(maxItems * 4); // RGBA for each item
    
    // For each item in our array, find its position in the atlas
    this.items.forEach((item, index) => {
      if (index >= maxItems) return;
      
      // Find this item's entry in the atlas mapping (O(1) lookup)
      const atlasEntry = this.atlasMappingMap.get(item.id?.toString() || '');
      
      if (atlasEntry) {
        // Calculate absolute position across all atlases
        // Atlas entry has x, y coordinates and atlas index
        const tileSize = atlasEntry.width || 256; // Use the tile size from mapping
        const tilesPerRow = this.atlasSize; // 16 for desktop, 8 for mobile
        const cellX = atlasEntry.x / tileSize;
        const cellY = atlasEntry.y / tileSize;
        const positionInAtlas = cellY * tilesPerRow + cellX;
        const itemsPerAtlas = tilesPerRow * tilesPerRow; // 256 for desktop, 64 for mobile
        const absolutePosition = atlasEntry.atlas * itemsPerAtlas + positionInAtlas;
        
        // Store in texture as normalized value (0-1)
        mappingData[index * 4] = absolutePosition / 1024.0; // R channel
        mappingData[index * 4 + 1] = 0; // G channel (unused)
        mappingData[index * 4 + 2] = 0; // B channel (unused)
        mappingData[index * 4 + 3] = 1; // A channel
        
        if (index < 5) {
          console.log(`Item ${index} (ID ${item.id}): maps to atlas position ${absolutePosition} (atlas ${atlasEntry.atlas}, pos ${positionInAtlas})`);
        }
      } else {
        // Item not in atlas - will use modulo fallback in shader
        // Store invalid position
        mappingData[index * 4] = -1;
        mappingData[index * 4 + 1] = 0;
        mappingData[index * 4 + 2] = 0;
        mappingData[index * 4 + 3] = 1;
      }
    });
    
    // Clean up old texture if exists
    if (this.atlasPositionMapTexture) {
      gl.deleteTexture(this.atlasPositionMapTexture);
    }
    
    // Create texture
    this.atlasPositionMapTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, this.atlasPositionMapTexture);
    
    // Always use float texture in WebGL2 - we can sample from float textures without extensions
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.RGBA32F, // Use floating point texture
      maxItems,
      1, // 1D texture (width x 1)
      0,
      gl.RGBA,
      gl.FLOAT,
      mappingData
    );
    
    // Set texture parameters - no filtering needed for data texture
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    
    // console.log(`Atlas position map texture created for ${maxItems} items`);
  }
  
  private async loadHighResTexture(index: number): Promise<void> {
    // DISABLED: Hi-res overlay system to prevent image swapping
    // All images now come from the hardcoded atlas only
    return;
  }

  private initDiscInstances(count: number): void {
    if (!this.gl || !this.discVAO) return;
    const gl = this.gl;

    const matricesArray = new Float32Array(count * 16);
    const matrices: Float32Array[] = [];
    for (let i = 0; i < count; ++i) {
      const instanceMatrixArray = new Float32Array(
        matricesArray.buffer,
        i * 16 * 4,
        16
      );
      mat4.identity(instanceMatrixArray as unknown as mat4);
      matrices.push(instanceMatrixArray);
    }

    this.discInstances = {
      matricesArray,
      matrices,
      buffer: gl.createBuffer(),
    };

    gl.bindVertexArray(this.discVAO);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.discInstances.buffer);
    gl.bufferData(
      gl.ARRAY_BUFFER,
      this.discInstances.matricesArray.byteLength,
      gl.DYNAMIC_DRAW
    );

    const mat4AttribSlotCount = 4;
    const bytesPerMatrix = 16 * 4;
    for (let j = 0; j < mat4AttribSlotCount; ++j) {
      const loc = this.discLocations.aInstanceMatrix + j;
      gl.enableVertexAttribArray(loc);
      gl.vertexAttribPointer(
        loc,
        4,
        gl.FLOAT,
        false,
        bytesPerMatrix,
        j * 4 * 4
      );
      gl.vertexAttribDivisor(loc, 1);
    }
    gl.bindBuffer(gl.ARRAY_BUFFER, null);
    gl.bindVertexArray(null);
  }

  private animate(deltaTime: number): void {
    if (!this.gl) return;
    this.control.update(deltaTime, this.TARGET_FRAME_DURATION);

    // Transform positions using pre-allocated arrays
    for (let i = 0; i < this.instancePositions.length; i++) {
      vec3.transformQuat(
        this.animationTempPositions[i], 
        this.instancePositions[i], 
        this.control.orientation
      );
    }
    
    const scale = 0.25;
    const SCALE_INTENSITY = 0.6;

    // Process each position using pre-allocated matrices
    for (let ndx = 0; ndx < this.animationTempPositions.length; ndx++) {
      const p = this.animationTempPositions[ndx];
      const s =
        (Math.abs(p[2]) / this.SPHERE_RADIUS) * SCALE_INTENSITY +
        (1 - SCALE_INTENSITY);
      const finalScale = s * scale;
      
      // Use pre-allocated matrix for this instance
      const matrix = this.animationTempMatrices[ndx];
      
      // Reset matrix to identity first
      mat4.identity(matrix);
      
      // Build transformation using pre-allocated temp matrices
      vec3.negate(this.animationTempVec3, p);
      mat4.fromTranslation(this.animationTempMatrix1, this.animationTempVec3);
      mat4.multiply(matrix, matrix, this.animationTempMatrix1);
      
      mat4.targetTo(this.animationTempMatrix2, [0, 0, 0], p, [0, 1, 0]);
      mat4.multiply(matrix, matrix, this.animationTempMatrix2);
      
      mat4.fromScaling(this.animationTempMatrix3, [finalScale, finalScale, finalScale]);
      mat4.multiply(matrix, matrix, this.animationTempMatrix3);
      
      mat4.fromTranslation(this.animationTempMatrix4, [0, 0, -this.SPHERE_RADIUS]);
      mat4.multiply(matrix, matrix, this.animationTempMatrix4);

      mat4.copy(this.discInstances.matrices[ndx], matrix);
    }

    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.discInstances.buffer);
    this.gl.bufferSubData(
      this.gl.ARRAY_BUFFER,
      0,
      this.discInstances.matricesArray
    );
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);

    this.smoothRotationVelocity = this.control.rotationVelocity;
  }

  private render(): void {
    if (!this.gl || !this.discProgram) return;
    const gl = this.gl;
    
    // Skip rendering if we're using fallback but atlases are available
    if (this.usingFallbackTexture && this.atlases.length > 0) {
      // console.log('Skipping render - switching from fallback to atlas textures');
      this.tex = this.atlases[0];
      this.usingFallbackTexture = false;
    }

    gl.useProgram(this.discProgram);
    gl.enable(gl.CULL_FACE);
    gl.enable(gl.DEPTH_TEST);

    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    gl.uniformMatrix4fv(
      this.discLocations.uWorldMatrix,
      false,
      this.worldMatrix
    );
    gl.uniformMatrix4fv(
      this.discLocations.uViewMatrix,
      false,
      this.camera.matrices.view
    );
    gl.uniformMatrix4fv(
      this.discLocations.uProjectionMatrix,
      false,
      this.camera.matrices.projection
    );
    if (this.discLocations.uCameraPosition) {
      gl.uniform3f(
        this.discLocations.uCameraPosition,
        this.camera.position[0],
        this.camera.position[1],
        this.camera.position[2]
      );
    }
    gl.uniform4f(
      this.discLocations.uRotationAxisVelocity,
      this.control.rotationAxis[0],
      this.control.rotationAxis[1],
      this.control.rotationAxis[2],
      this.smoothRotationVelocity * 1.1
    );

    gl.uniform1i(this.discLocations.uItemCount, this.DISC_INSTANCE_COUNT);
    gl.uniform1i(this.discLocations.uAtlasSize, this.atlasSize);

    if (this.discLocations.uFrames) {
      gl.uniform1f(this.discLocations.uFrames, this._frames);
    }
    if (this.discLocations.uScaleFactor) {
      gl.uniform1f(this.discLocations.uScaleFactor, this.scaleFactor);
    }
    
    // Set the atlas position mapping texture
    if (this.atlasPositionMapTexture && this.discLocations.uAtlasPositionMap) {
      gl.uniform1i(this.discLocations.uAtlasPositionMap, 4);
      gl.activeTexture(gl.TEXTURE4);
      gl.bindTexture(gl.TEXTURE_2D, this.atlasPositionMapTexture);
      if (this.discLocations.uMaxItems) {
        gl.uniform1i(this.discLocations.uMaxItems, Math.min(this.items.length, 1024));
      }
    }

    // Bind all available atlases
    const atlas0 = (this.atlases.length > 0 && !this.usingFallbackTexture) 
      ? this.atlases[0] 
      : this.tex;
    
    gl.uniform1i(this.discLocations.uTex, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, atlas0);
    
    // Bind second atlas if available
    if (this.atlases.length > 1) {
      gl.uniform1i(this.discLocations.uTex1, 2);
      gl.activeTexture(gl.TEXTURE2);
      gl.bindTexture(gl.TEXTURE_2D, this.atlases[1]);
    } else {
      // Bind fallback
      gl.uniform1i(this.discLocations.uTex1, 2);
      gl.activeTexture(gl.TEXTURE2);
      gl.bindTexture(gl.TEXTURE_2D, atlas0);
    }
    
    // Bind third atlas if available
    if (this.atlases.length > 2) {
      gl.uniform1i(this.discLocations.uTex2, 3);
      gl.activeTexture(gl.TEXTURE3);
      gl.bindTexture(gl.TEXTURE_2D, this.atlases[2]);
    } else {
      // Bind fallback
      gl.uniform1i(this.discLocations.uTex2, 3);
      gl.activeTexture(gl.TEXTURE3);
      gl.bindTexture(gl.TEXTURE_2D, atlas0);
    }
    
    // Bind high-res texture if available
    gl.uniform1i(this.discLocations.uHighTex, 1);
    gl.activeTexture(gl.TEXTURE1);
    if (this.hiResTexture && this.hiResIndex >= 0) {
      gl.bindTexture(gl.TEXTURE_2D, this.hiResTexture);
      gl.uniform1f(this.discLocations.uHighId, this.hiResIndex);
    } else {
      // Bind dummy texture to avoid shader errors
      gl.bindTexture(gl.TEXTURE_2D, atlas0);
      gl.uniform1f(this.discLocations.uHighId, -1);
    }

    gl.bindVertexArray(this.discVAO);
    gl.drawElementsInstanced(
      gl.TRIANGLES,
      this.discBuffers.indices.length,
      gl.UNSIGNED_SHORT,
      0,
      this.DISC_INSTANCE_COUNT
    );
    gl.bindVertexArray(null);
  }

  private updateCameraMatrix(): void {
    mat4.targetTo(
      this.camera.matrix,
      this.camera.position,
      [0, 0, 0],
      this.camera.up
    );
    mat4.invert(this.camera.matrices.view, this.camera.matrix);
  }

  private updateProjectionMatrix(): void {
    if (!this.gl) return;
    const canvasEl = this.gl.canvas as HTMLCanvasElement;
    this.camera.aspect = canvasEl.clientWidth / canvasEl.clientHeight;
    // Use fixed height from original sphere to maintain consistent FOV
    const height = 2.0 * 0.35; // Always use original sphere's height
    const distance = this.camera.position[2];
    if (this.camera.aspect > 1) {
      this.camera.fov = 2 * Math.atan(height / distance);
    } else {
      this.camera.fov = 2 * Math.atan(height / this.camera.aspect / distance);
    }
    mat4.perspective(
      this.camera.matrices.projection,
      this.camera.fov,
      this.camera.aspect,
      this.camera.near,
      this.camera.far
    );
    mat4.invert(
      this.camera.matrices.inversProjection,
      this.camera.matrices.projection
    );
  }

  private onControlUpdate(deltaTime: number): void {
    const timeScale = deltaTime / this.TARGET_FRAME_DURATION + 0.0001;
    let damping = 5 / timeScale;
    let cameraTargetZ: number;

    const isMoving =
      this.control.isPointerDown ||
      Math.abs(this.smoothRotationVelocity) > 0.01;

    if (isMoving !== this.movementActive) {
      this.movementActive = isMoving;
      this.onMovementChange(isMoving);
    }

    if (!this.control.isPointerDown) {
      const nearestVertexIndex = this.findNearestVertexIndex();
      // Use modulo to match shader behavior
      const itemIndex = nearestVertexIndex % this.items.length;
      
      // Only update if the focused item has changed
      if (itemIndex !== this.currentFocusedIndex) {
        this.currentFocusedIndex = itemIndex;
        // Snap to item ${itemIndex}
        
        // Notify parent component of the new focused item
        this.onActiveItemChange(itemIndex);
        
        // Load high-res texture for the active item
        this.loadHighResTexture(itemIndex);
      }
      
      const snapDirection = vec3.normalize(
        vec3.create(),
        this.getVertexWorldPosition(nearestVertexIndex)
      );
      this.control.snapTargetDirection = snapDirection;
      
      // When snapped: maintain constant distance from sphere surface
      // Original: sphere radius 2.0, camera at 3.0 (1.0 unit from surface)
      cameraTargetZ = this.SPHERE_RADIUS + 1.0;
    } else {
      // When dragging: use proportional distance based on sphere radius
      // Original: radius 2.0, camera starts at 6.0 (3x) and goes up to ~86 (43x)
      const minMultiplier = 3.0;  // Start at 3x radius for good sphere visibility
      const maxMultiplier = 43.0; // Maximum zoom out at 43x radius
      const velocityRange = maxMultiplier - minMultiplier;
      const velocityMultiplier = this.control.rotationVelocity * velocityRange;
      cameraTargetZ = this.SPHERE_RADIUS * (minMultiplier + velocityMultiplier);
      damping = 7 / timeScale;
    }

    this.camera.position[2] +=
      (cameraTargetZ - this.camera.position[2]) / damping;
    this.updateCameraMatrix();
  }

  private findNearestVertexIndex(): number {
    const n = this.control.snapDirection;
    const inversOrientation = quat.conjugate(
      quat.create(),
      this.control.orientation
    );
    const nt = vec3.transformQuat(vec3.create(), n, inversOrientation);

    let maxD = -1;
    let nearestVertexIndex = 0;
    for (let i = 0; i < this.instancePositions.length; ++i) {
      const d = vec3.dot(nt, this.instancePositions[i]);
      if (d > maxD) {
        maxD = d;
        nearestVertexIndex = i;
      }
    }
    return nearestVertexIndex;
  }

  private getVertexWorldPosition(index: number): vec3 {
    const nearestVertexPos = this.instancePositions[index];
    return vec3.transformQuat(
      vec3.create(),
      nearestVertexPos,
      this.control.orientation
    );
  }

  private setInitialFocus(focusId: number): void {
    // Find the item with matching ID
    const itemIndex = this.items.findIndex(item => item.id === focusId);
    if (itemIndex === -1) {
      // Initial focus item ${focusId} not found
      return;
    }
    
    // Set the current focused index and notify
    this.currentFocusedIndex = itemIndex;
    this.onActiveItemChange(itemIndex);
    
    // Load high-res texture immediately for initial focus
    this.loadHighResTexture(itemIndex);
    
    // Get the vertex position for this item
    const vertexIndex = itemIndex % this.instancePositions.length;
    const targetPos = this.instancePositions[vertexIndex];
    
    // Normalize the target position
    const targetNormalized = vec3.normalize(vec3.create(), targetPos);
    
    // The front direction we want to align to (positive Z)
    const frontDirection = vec3.fromValues(0, 0, 1);
    
    // Calculate rotation axis (cross product)
    const axis = vec3.cross(vec3.create(), targetNormalized, frontDirection);
    const axisLength = vec3.length(axis);
    
    // Calculate angle between vectors
    const dotProduct = vec3.dot(targetNormalized, frontDirection);
    const angle = Math.acos(Math.max(-1, Math.min(1, dotProduct)));
    
    // Only rotate if there's a meaningful angle
    if (axisLength > 0.001 && angle > 0.001) {
      vec3.normalize(axis, axis);
      // Rotate in the opposite direction to bring target to front
      quat.setAxisAngle(this.control.orientation, axis, -angle);
      // Set initial focus to item ${itemIndex} (ID: ${focusId})
    } else {
      // Item ${itemIndex} (ID: ${focusId}) is already at front
    }
  }

  public dispose(): void {
    if (this.animationFrameId) {
      cancelAnimationFrame(this.animationFrameId);
    }
    if (this.hiResLoadTimer) {
      clearTimeout(this.hiResLoadTimer);
      this.hiResLoadTimer = null;
    }
    // Cancel any in-progress atlas creation
    if (this.atlasAbortController) {
      this.atlasAbortController.abort();
      this.atlasAbortController = null;
    }
    const gl = this.gl;
    if (!gl) return;

    if (this.discProgram) {
      gl.deleteProgram(this.discProgram);
    }
    if (this.discVAO) {
      gl.deleteVertexArray(this.discVAO);
    }
    if (this.discInstances && this.discInstances.buffer) {
      gl.deleteBuffer(this.discInstances.buffer);
    }
    if (this.tex) {
      gl.deleteTexture(this.tex);
    }
    this.atlases.forEach(atlas => {
      if(atlas) gl.deleteTexture(atlas)
    });
    if (this.hiResTexture) {
      gl.deleteTexture(this.hiResTexture);
    }
    if (this.atlasPositionMapTexture) {
      gl.deleteTexture(this.atlasPositionMapTexture);
    }
    
    this.gl = null;
  }

  public updateItems(newItems: MenuItem[]): void {
    this.items = newItems;
    // Reset hi-res state to avoid overlay mismatch after filtering
    this.hiResIndex = -1;
    if (this.hiResTexture && this.gl) {
      this.gl.deleteTexture(this.hiResTexture);
      this.hiResTexture = null;
    }
    
    // Always update vertex count to match item count
    const newCount = newItems.length || 1;
    const oldCount = this.DISC_INSTANCE_COUNT;
    
    // Calculate new sphere radius based on item count
    const newRadius = this.dynamicPositions.calculateOptimalRadius(newCount);
    this.SPHERE_RADIUS = newRadius;
    
    // Generate new positions for the exact number of items
    this.instancePositions = this.dynamicPositions.generatePositions(newCount, newRadius);
    this.DISC_INSTANCE_COUNT = newCount;
    
    // Reallocate animation arrays if count changed
    if (oldCount !== newCount) {
      // Geometry updated: ${oldCount}  ${newCount} instances
      
      // Reallocate pre-allocated arrays for new item count
      this.animationTempPositions = new Array(newCount);
      this.animationTempMatrices = new Array(newCount);
      for (let i = 0; i < newCount; i++) {
        this.animationTempPositions[i] = vec3.create();
        this.animationTempMatrices[i] = mat4.create();
      }
    }
    
    // Update camera position at constant distance from sphere surface
    vec3.set(this.camera.position, 0, 0, newRadius + 1.0);
    this.updateCameraMatrix();
    
    // Reinitialize instance buffer
    this.initDiscInstances(this.DISC_INSTANCE_COUNT);
    
    // Don't regenerate atlases - just update the position mapping
    // The master atlas contains all items, we just need to map the filtered items to their positions
    if (this.atlasMapping && this.atlasMapping.length > 0) {
      console.log(`Updating position map for ${newItems.length} filtered items`);
      this.buildAtlasPositionMap();
    } else {
      console.warn('Atlas mapping not available, items may show incorrect images');
    }

    // Don't eager-load hi-res, let it load only when truly focused
  }
}

const defaultItems: MenuItem[] = [
  {
    image: "https://picsum.photos/900/900?grayscale",
    link: "https://google.com/",
    title: "",
    description: "",
  },
];

interface InfiniteMenuProps {
  items?: MenuItem[];
  initialFocusId?: number;
  onItemFocus?: (item: MenuItem | null) => void;
}

const InfiniteMenu = ({ items = [], initialFocusId, onItemFocus }: InfiniteMenuProps) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const menuInstanceRef = useRef<InfiniteGridMenu | null>(null);
  const [, setActiveItem] = useState(items.length > 0 ? items[0] : null);
  const [, setIsMoving] = useState<boolean>(false);
  const [isLoading, setIsLoading] = useState<boolean>(true);

  // Mount WebGL instance once
  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas || menuInstanceRef.current) return;

    const handleActiveItem = (index: number) => {
      const itemIndex = index % (items.length || 1);
      const item = (items.length ? items : defaultItems)[itemIndex];
      setActiveItem(item);
      onItemFocus?.(item);
    };

    // Show loading state
    setIsLoading(true);
    
    // Create instance once with atlas loaded callback
    const inst = new InfiniteGridMenu(
      canvas,
      items.length ? items : defaultItems,
      handleActiveItem,
      setIsMoving,
      (sk) => sk.run(),
      initialFocusId,
      () => {
        // Hide loading after a short delay to ensure smooth transition
        setTimeout(() => setIsLoading(false), 100);
      }
    );
    
    menuInstanceRef.current = inst;

    const onResize = () => inst.resize();
    window.addEventListener("resize", onResize);
    onResize();

    return () => {
      window.removeEventListener("resize", onResize);
      inst.dispose();
      menuInstanceRef.current = null;
    };
  }, []); // No dependencies - mount once

  // Update items only (no dispose/recreate)
  useEffect(() => {
    if (menuInstanceRef.current) {
      menuInstanceRef.current.updateItems(items.length ? items : defaultItems);
    }
  }, [items]);


  return (
    <div className="relative w-full h-full">
      <canvas
        id="infinite-grid-menu-canvas"
        ref={canvasRef}
        className={`cursor-grab w-full h-full overflow-hidden relative outline-none active:cursor-grabbing transition-opacity duration-300 ${
          isLoading ? 'opacity-0' : 'opacity-100'
        }`}
      />
      
      {/* Loading indicator */}
      {isLoading && (
        <div className="absolute inset-0 flex items-center justify-center bg-black">
          <div className="text-white/60 font-mono text-sm uppercase tracking-wider animate-pulse">
            Loading
          </div>
        </div>
      )}

      {/* Item details are now shown in the right panel */}
    </div>
  );
};

export default InfiniteMenu;
</file>

</files>
